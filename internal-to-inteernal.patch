From 613cb303ac0d22786e9c4d153e993c6c8adcd2bb Mon Sep 17 00:00:00 2001
From: Jan Chaloupka <jchaloup@redhat.com>
Date: Wed, 14 Oct 2015 12:37:01 +0200
Subject: [PATCH] internal to inteernal

---
 .../src/github.com/gonum/blas/native/dgemm.go      |   2 +-
 .../github.com/gonum/blas/native/level1double.go   |   2 +-
 .../gonum/blas/native/level1double_ddot.go         |   2 +-
 .../github.com/gonum/blas/native/level1single.go   |   2 +-
 .../gonum/blas/native/level1single_dsdot.go        |   2 +-
 .../gonum/blas/native/level1single_sdot.go         |   2 +-
 .../gonum/blas/native/level1single_sdsdot.go       |   2 +-
 .../github.com/gonum/blas/native/level2double.go   |   2 +-
 .../github.com/gonum/blas/native/level2single.go   |   2 +-
 .../github.com/gonum/blas/native/level3double.go   |   2 +-
 .../github.com/gonum/blas/native/level3single.go   |   2 +-
 .../src/github.com/gonum/blas/native/sgemm.go      |   2 +-
 .../src/github.com/gonum/graph/inteernal/linear.go |  73 ++++
 .../src/github.com/gonum/graph/inteernal/set.go    | 211 +++++++++++
 .../github.com/gonum/graph/inteernal/set_test.go   | 413 +++++++++++++++++++++
 .../src/github.com/gonum/graph/inteernal/sort.go   |  28 ++
 .../src/github.com/gonum/graph/internal/linear.go  |  73 ----
 .../src/github.com/gonum/graph/internal/set.go     | 211 -----------
 .../github.com/gonum/graph/internal/set_test.go    | 413 ---------------------
 .../src/github.com/gonum/graph/internal/sort.go    |  28 --
 .../github.com/gonum/graph/network/betweenness.go  |   2 +-
 .../src/github.com/gonum/graph/path/a_star.go      |   2 +-
 .../github.com/gonum/graph/path/control_flow.go    |   2 +-
 .../github.com/gonum/graph/path/dijkstra_test.go   |   2 +-
 .../gonum/graph/path/floydwarshall_test.go         |   2 +-
 .../gonum/graph/path/johnson_apsp_test.go          |   2 +-
 .../github.com/gonum/graph/path/spanning_tree.go   |   2 +-
 .../github.com/gonum/graph/topo/bron_kerbosch.go   |   2 +-
 .../gonum/graph/topo/bron_kerbosch_test.go         |   2 +-
 .../github.com/gonum/graph/topo/johnson_cycles.go  |   2 +-
 .../gonum/graph/topo/johnson_cycles_test.go        |   2 +-
 .../src/github.com/gonum/graph/topo/tarjan.go      |   2 +-
 .../src/github.com/gonum/graph/topo/tarjan_test.go |   2 +-
 .../src/github.com/gonum/graph/topo/topo_test.go   |   2 +-
 .../github.com/gonum/graph/traverse/traverse.go    |   2 +-
 .../gonum/graph/traverse/traverse_test.go          |   2 +-
 .../src/github.com/gonum/inteernal/asm/caxpy.go    |  22 ++
 .../src/github.com/gonum/inteernal/asm/cdotc.go    |  23 ++
 .../src/github.com/gonum/inteernal/asm/cdotu.go    |  23 ++
 .../src/github.com/gonum/inteernal/asm/complex     |  58 +++
 .../src/github.com/gonum/inteernal/asm/conj.go     |   7 +
 .../src/github.com/gonum/inteernal/asm/daxpy.go    |  22 ++
 .../github.com/gonum/inteernal/asm/daxpy_amd64.go  |  12 +
 .../github.com/gonum/inteernal/asm/daxpy_amd64.s   | 140 +++++++
 .../src/github.com/gonum/inteernal/asm/ddot.go     |  23 ++
 .../github.com/gonum/inteernal/asm/ddot_amd64.go   |  10 +
 .../github.com/gonum/inteernal/asm/ddot_amd64.s    | 140 +++++++
 .../src/github.com/gonum/inteernal/asm/dsdot.go    |  23 ++
 .../src/github.com/gonum/inteernal/asm/generate.go |   8 +
 .../src/github.com/gonum/inteernal/asm/saxpy.go    |  22 ++
 .../src/github.com/gonum/inteernal/asm/sdot.go     |  23 ++
 .../gonum/inteernal/asm/single_precision           |  30 ++
 .../src/github.com/gonum/inteernal/asm/zaxpy.go    |  22 ++
 .../src/github.com/gonum/inteernal/asm/zdotc.go    |  25 ++
 .../src/github.com/gonum/inteernal/asm/zdotu.go    |  23 ++
 .../src/github.com/gonum/internal/asm/caxpy.go     |  22 --
 .../src/github.com/gonum/internal/asm/cdotc.go     |  23 --
 .../src/github.com/gonum/internal/asm/cdotu.go     |  23 --
 .../src/github.com/gonum/internal/asm/complex      |  58 ---
 .../src/github.com/gonum/internal/asm/conj.go      |   7 -
 .../src/github.com/gonum/internal/asm/daxpy.go     |  22 --
 .../github.com/gonum/internal/asm/daxpy_amd64.go   |  12 -
 .../github.com/gonum/internal/asm/daxpy_amd64.s    | 140 -------
 .../src/github.com/gonum/internal/asm/ddot.go      |  23 --
 .../github.com/gonum/internal/asm/ddot_amd64.go    |  10 -
 .../src/github.com/gonum/internal/asm/ddot_amd64.s | 140 -------
 .../src/github.com/gonum/internal/asm/dsdot.go     |  23 --
 .../src/github.com/gonum/internal/asm/generate.go  |   8 -
 .../src/github.com/gonum/internal/asm/saxpy.go     |  22 --
 .../src/github.com/gonum/internal/asm/sdot.go      |  23 --
 .../github.com/gonum/internal/asm/single_precision |  30 --
 .../src/github.com/gonum/internal/asm/zaxpy.go     |  22 --
 .../src/github.com/gonum/internal/asm/zdotc.go     |  25 --
 .../src/github.com/gonum/internal/asm/zdotu.go     |  23 --
 .../src/github.com/gonum/matrix/mat64/inner.go     |   2 +-
 75 files changed, 1410 insertions(+), 1410 deletions(-)
 create mode 100644 Godeps/_workspace/src/github.com/gonum/graph/inteernal/linear.go
 create mode 100644 Godeps/_workspace/src/github.com/gonum/graph/inteernal/set.go
 create mode 100644 Godeps/_workspace/src/github.com/gonum/graph/inteernal/set_test.go
 create mode 100644 Godeps/_workspace/src/github.com/gonum/graph/inteernal/sort.go
 delete mode 100644 Godeps/_workspace/src/github.com/gonum/graph/internal/linear.go
 delete mode 100644 Godeps/_workspace/src/github.com/gonum/graph/internal/set.go
 delete mode 100644 Godeps/_workspace/src/github.com/gonum/graph/internal/set_test.go
 delete mode 100644 Godeps/_workspace/src/github.com/gonum/graph/internal/sort.go
 create mode 100644 Godeps/_workspace/src/github.com/gonum/inteernal/asm/caxpy.go
 create mode 100644 Godeps/_workspace/src/github.com/gonum/inteernal/asm/cdotc.go
 create mode 100644 Godeps/_workspace/src/github.com/gonum/inteernal/asm/cdotu.go
 create mode 100644 Godeps/_workspace/src/github.com/gonum/inteernal/asm/complex
 create mode 100644 Godeps/_workspace/src/github.com/gonum/inteernal/asm/conj.go
 create mode 100644 Godeps/_workspace/src/github.com/gonum/inteernal/asm/daxpy.go
 create mode 100644 Godeps/_workspace/src/github.com/gonum/inteernal/asm/daxpy_amd64.go
 create mode 100644 Godeps/_workspace/src/github.com/gonum/inteernal/asm/daxpy_amd64.s
 create mode 100644 Godeps/_workspace/src/github.com/gonum/inteernal/asm/ddot.go
 create mode 100644 Godeps/_workspace/src/github.com/gonum/inteernal/asm/ddot_amd64.go
 create mode 100644 Godeps/_workspace/src/github.com/gonum/inteernal/asm/ddot_amd64.s
 create mode 100644 Godeps/_workspace/src/github.com/gonum/inteernal/asm/dsdot.go
 create mode 100644 Godeps/_workspace/src/github.com/gonum/inteernal/asm/generate.go
 create mode 100644 Godeps/_workspace/src/github.com/gonum/inteernal/asm/saxpy.go
 create mode 100644 Godeps/_workspace/src/github.com/gonum/inteernal/asm/sdot.go
 create mode 100644 Godeps/_workspace/src/github.com/gonum/inteernal/asm/single_precision
 create mode 100644 Godeps/_workspace/src/github.com/gonum/inteernal/asm/zaxpy.go
 create mode 100644 Godeps/_workspace/src/github.com/gonum/inteernal/asm/zdotc.go
 create mode 100644 Godeps/_workspace/src/github.com/gonum/inteernal/asm/zdotu.go
 delete mode 100644 Godeps/_workspace/src/github.com/gonum/internal/asm/caxpy.go
 delete mode 100644 Godeps/_workspace/src/github.com/gonum/internal/asm/cdotc.go
 delete mode 100644 Godeps/_workspace/src/github.com/gonum/internal/asm/cdotu.go
 delete mode 100644 Godeps/_workspace/src/github.com/gonum/internal/asm/complex
 delete mode 100644 Godeps/_workspace/src/github.com/gonum/internal/asm/conj.go
 delete mode 100644 Godeps/_workspace/src/github.com/gonum/internal/asm/daxpy.go
 delete mode 100644 Godeps/_workspace/src/github.com/gonum/internal/asm/daxpy_amd64.go
 delete mode 100644 Godeps/_workspace/src/github.com/gonum/internal/asm/daxpy_amd64.s
 delete mode 100644 Godeps/_workspace/src/github.com/gonum/internal/asm/ddot.go
 delete mode 100644 Godeps/_workspace/src/github.com/gonum/internal/asm/ddot_amd64.go
 delete mode 100644 Godeps/_workspace/src/github.com/gonum/internal/asm/ddot_amd64.s
 delete mode 100644 Godeps/_workspace/src/github.com/gonum/internal/asm/dsdot.go
 delete mode 100644 Godeps/_workspace/src/github.com/gonum/internal/asm/generate.go
 delete mode 100644 Godeps/_workspace/src/github.com/gonum/internal/asm/saxpy.go
 delete mode 100644 Godeps/_workspace/src/github.com/gonum/internal/asm/sdot.go
 delete mode 100644 Godeps/_workspace/src/github.com/gonum/internal/asm/single_precision
 delete mode 100644 Godeps/_workspace/src/github.com/gonum/internal/asm/zaxpy.go
 delete mode 100644 Godeps/_workspace/src/github.com/gonum/internal/asm/zdotc.go
 delete mode 100644 Godeps/_workspace/src/github.com/gonum/internal/asm/zdotu.go

diff --git a/Godeps/_workspace/src/github.com/gonum/blas/native/dgemm.go b/Godeps/_workspace/src/github.com/gonum/blas/native/dgemm.go
index 850f62c..8dc9920 100644
--- a/Godeps/_workspace/src/github.com/gonum/blas/native/dgemm.go
+++ b/Godeps/_workspace/src/github.com/gonum/blas/native/dgemm.go
@@ -10,7 +10,7 @@ import (
 	"sync"
 
 	"github.com/gonum/blas"
-	"github.com/gonum/internal/asm"
+	"github.com/gonum/inteernal/asm"
 )
 
 // Dgemm computes
diff --git a/Godeps/_workspace/src/github.com/gonum/blas/native/level1double.go b/Godeps/_workspace/src/github.com/gonum/blas/native/level1double.go
index 0d77243..65f2972 100644
--- a/Godeps/_workspace/src/github.com/gonum/blas/native/level1double.go
+++ b/Godeps/_workspace/src/github.com/gonum/blas/native/level1double.go
@@ -8,7 +8,7 @@ import (
 	"math"
 
 	"github.com/gonum/blas"
-	"github.com/gonum/internal/asm"
+	"github.com/gonum/inteernal/asm"
 )
 
 var _ blas.Float64Level1 = Implementation{}
diff --git a/Godeps/_workspace/src/github.com/gonum/blas/native/level1double_ddot.go b/Godeps/_workspace/src/github.com/gonum/blas/native/level1double_ddot.go
index 7af4e04..84a16ed 100644
--- a/Godeps/_workspace/src/github.com/gonum/blas/native/level1double_ddot.go
+++ b/Godeps/_workspace/src/github.com/gonum/blas/native/level1double_ddot.go
@@ -5,7 +5,7 @@
 package native
 
 import (
-	"github.com/gonum/internal/asm"
+	"github.com/gonum/inteernal/asm"
 )
 
 // Ddot computes the dot product of the two vectors
diff --git a/Godeps/_workspace/src/github.com/gonum/blas/native/level1single.go b/Godeps/_workspace/src/github.com/gonum/blas/native/level1single.go
index 6bcba83..ca82629 100644
--- a/Godeps/_workspace/src/github.com/gonum/blas/native/level1single.go
+++ b/Godeps/_workspace/src/github.com/gonum/blas/native/level1single.go
@@ -10,7 +10,7 @@ import (
 	math "github.com/gonum/blas/native/internal/math32"
 
 	"github.com/gonum/blas"
-	"github.com/gonum/internal/asm"
+	"github.com/gonum/inteernal/asm"
 )
 
 var _ blas.Float32Level1 = Implementation{}
diff --git a/Godeps/_workspace/src/github.com/gonum/blas/native/level1single_dsdot.go b/Godeps/_workspace/src/github.com/gonum/blas/native/level1single_dsdot.go
index 4665a01..a438155 100644
--- a/Godeps/_workspace/src/github.com/gonum/blas/native/level1single_dsdot.go
+++ b/Godeps/_workspace/src/github.com/gonum/blas/native/level1single_dsdot.go
@@ -7,7 +7,7 @@
 package native
 
 import (
-	"github.com/gonum/internal/asm"
+	"github.com/gonum/inteernal/asm"
 )
 
 // Dsdot computes the dot product of the two vectors
diff --git a/Godeps/_workspace/src/github.com/gonum/blas/native/level1single_sdot.go b/Godeps/_workspace/src/github.com/gonum/blas/native/level1single_sdot.go
index 1e5b565..7d96b74 100644
--- a/Godeps/_workspace/src/github.com/gonum/blas/native/level1single_sdot.go
+++ b/Godeps/_workspace/src/github.com/gonum/blas/native/level1single_sdot.go
@@ -7,7 +7,7 @@
 package native
 
 import (
-	"github.com/gonum/internal/asm"
+	"github.com/gonum/inteernal/asm"
 )
 
 // Sdot computes the dot product of the two vectors
diff --git a/Godeps/_workspace/src/github.com/gonum/blas/native/level1single_sdsdot.go b/Godeps/_workspace/src/github.com/gonum/blas/native/level1single_sdsdot.go
index d58be3d..79543d4 100644
--- a/Godeps/_workspace/src/github.com/gonum/blas/native/level1single_sdsdot.go
+++ b/Godeps/_workspace/src/github.com/gonum/blas/native/level1single_sdsdot.go
@@ -7,7 +7,7 @@
 package native
 
 import (
-	"github.com/gonum/internal/asm"
+	"github.com/gonum/inteernal/asm"
 )
 
 // Sdsdot computes the dot product of the two vectors plus a constant
diff --git a/Godeps/_workspace/src/github.com/gonum/blas/native/level2double.go b/Godeps/_workspace/src/github.com/gonum/blas/native/level2double.go
index 6d59559..af62cd1 100644
--- a/Godeps/_workspace/src/github.com/gonum/blas/native/level2double.go
+++ b/Godeps/_workspace/src/github.com/gonum/blas/native/level2double.go
@@ -6,7 +6,7 @@ package native
 
 import (
 	"github.com/gonum/blas"
-	"github.com/gonum/internal/asm"
+	"github.com/gonum/inteernal/asm"
 )
 
 var _ blas.Float64Level2 = Implementation{}
diff --git a/Godeps/_workspace/src/github.com/gonum/blas/native/level2single.go b/Godeps/_workspace/src/github.com/gonum/blas/native/level2single.go
index b213ad6..6720c0e 100644
--- a/Godeps/_workspace/src/github.com/gonum/blas/native/level2single.go
+++ b/Godeps/_workspace/src/github.com/gonum/blas/native/level2single.go
@@ -8,7 +8,7 @@ package native
 
 import (
 	"github.com/gonum/blas"
-	"github.com/gonum/internal/asm"
+	"github.com/gonum/inteernal/asm"
 )
 
 var _ blas.Float32Level2 = Implementation{}
diff --git a/Godeps/_workspace/src/github.com/gonum/blas/native/level3double.go b/Godeps/_workspace/src/github.com/gonum/blas/native/level3double.go
index 5a19652..47d5d15 100644
--- a/Godeps/_workspace/src/github.com/gonum/blas/native/level3double.go
+++ b/Godeps/_workspace/src/github.com/gonum/blas/native/level3double.go
@@ -6,7 +6,7 @@ package native
 
 import (
 	"github.com/gonum/blas"
-	"github.com/gonum/internal/asm"
+	"github.com/gonum/inteernal/asm"
 )
 
 var _ blas.Float64Level3 = Implementation{}
diff --git a/Godeps/_workspace/src/github.com/gonum/blas/native/level3single.go b/Godeps/_workspace/src/github.com/gonum/blas/native/level3single.go
index 6bc9a56..82212a0 100644
--- a/Godeps/_workspace/src/github.com/gonum/blas/native/level3single.go
+++ b/Godeps/_workspace/src/github.com/gonum/blas/native/level3single.go
@@ -8,7 +8,7 @@ package native
 
 import (
 	"github.com/gonum/blas"
-	"github.com/gonum/internal/asm"
+	"github.com/gonum/inteernal/asm"
 )
 
 var _ blas.Float32Level3 = Implementation{}
diff --git a/Godeps/_workspace/src/github.com/gonum/blas/native/sgemm.go b/Godeps/_workspace/src/github.com/gonum/blas/native/sgemm.go
index 047d4e5..0387945 100644
--- a/Godeps/_workspace/src/github.com/gonum/blas/native/sgemm.go
+++ b/Godeps/_workspace/src/github.com/gonum/blas/native/sgemm.go
@@ -12,7 +12,7 @@ import (
 	"sync"
 
 	"github.com/gonum/blas"
-	"github.com/gonum/internal/asm"
+	"github.com/gonum/inteernal/asm"
 )
 
 // Sgemm computes
diff --git a/Godeps/_workspace/src/github.com/gonum/graph/inteernal/linear.go b/Godeps/_workspace/src/github.com/gonum/graph/inteernal/linear.go
new file mode 100644
index 0000000..3d64de9
--- /dev/null
+++ b/Godeps/_workspace/src/github.com/gonum/graph/inteernal/linear.go
@@ -0,0 +1,73 @@
+// Copyright ©2015 The gonum Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+package internal
+
+import (
+	"github.com/gonum/graph"
+)
+
+// NodeStack implements a LIFO stack of graph.Node.
+type NodeStack []graph.Node
+
+// Len returns the number of graph.Nodes on the stack.
+func (s *NodeStack) Len() int { return len(*s) }
+
+// Pop returns the last graph.Node on the stack and removes it
+// from the stack.
+func (s *NodeStack) Pop() graph.Node {
+	v := *s
+	v, n := v[:len(v)-1], v[len(v)-1]
+	*s = v
+	return n
+}
+
+// Push adds the node n to the stack at the last position.
+func (s *NodeStack) Push(n graph.Node) { *s = append(*s, n) }
+
+// NodeQueue implements a FIFO queue.
+type NodeQueue struct {
+	head int
+	data []graph.Node
+}
+
+// Len returns the number of graph.Nodes in the queue.
+func (q *NodeQueue) Len() int { return len(q.data) - q.head }
+
+// Enqueue adds the node n to the back of the queue.
+func (q *NodeQueue) Enqueue(n graph.Node) {
+	if len(q.data) == cap(q.data) && q.head > 0 {
+		l := q.Len()
+		copy(q.data, q.data[q.head:])
+		q.head = 0
+		q.data = append(q.data[:l], n)
+	} else {
+		q.data = append(q.data, n)
+	}
+}
+
+// Dequeue returns the graph.Node at the front of the queue and
+// removes it from the queue.
+func (q *NodeQueue) Dequeue() graph.Node {
+	if q.Len() == 0 {
+		panic("queue: empty queue")
+	}
+
+	var n graph.Node
+	n, q.data[q.head] = q.data[q.head], nil
+	q.head++
+
+	if q.Len() == 0 {
+		q.head = 0
+		q.data = q.data[:0]
+	}
+
+	return n
+}
+
+// Reset clears the queue for reuse.
+func (q *NodeQueue) Reset() {
+	q.head = 0
+	q.data = q.data[:0]
+}
diff --git a/Godeps/_workspace/src/github.com/gonum/graph/inteernal/set.go b/Godeps/_workspace/src/github.com/gonum/graph/inteernal/set.go
new file mode 100644
index 0000000..3ad1bc8
--- /dev/null
+++ b/Godeps/_workspace/src/github.com/gonum/graph/inteernal/set.go
@@ -0,0 +1,211 @@
+// Copyright ©2014 The gonum Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+package internal
+
+import (
+	"unsafe"
+
+	"github.com/gonum/graph"
+)
+
+// IntSet is a set of integer identifiers.
+type IntSet map[int]struct{}
+
+// The simple accessor methods for Set are provided to allow ease of
+// implementation change should the need arise.
+
+// Add inserts an element into the set.
+func (s IntSet) Add(e int) {
+	s[e] = struct{}{}
+}
+
+// Has reports the existence of the element in the set.
+func (s IntSet) Has(e int) bool {
+	_, ok := s[e]
+	return ok
+}
+
+// Remove deletes the specified element from the set.
+func (s IntSet) Remove(e int) {
+	delete(s, e)
+}
+
+// Count reports the number of elements stored in the set.
+func (s IntSet) Count() int {
+	return len(s)
+}
+
+// Same determines whether two sets are backed by the same store. In the
+// current implementation using hash maps it makes use of the fact that
+// hash maps (at least in the gc implementation) are passed as a pointer
+// to a runtime Hmap struct.
+//
+// A map is not seen by the runtime as a pointer though, so we cannot
+// directly compare the sets converted to unsafe.Pointer and need to take
+// the sets' addressed and dereference them as pointers to some comparable
+// type.
+func Same(s1, s2 Set) bool {
+	return *(*uintptr)(unsafe.Pointer(&s1)) == *(*uintptr)(unsafe.Pointer(&s2))
+}
+
+// A set is a set of nodes keyed in their integer identifiers.
+type Set map[int]graph.Node
+
+// The simple accessor methods for Set are provided to allow ease of
+// implementation change should the need arise.
+
+// Add inserts an element into the set.
+func (s Set) Add(n graph.Node) {
+	s[n.ID()] = n
+}
+
+// Remove deletes the specified element from the set.
+func (s Set) Remove(e graph.Node) {
+	delete(s, e.ID())
+}
+
+// Has reports the existence of the element in the set.
+func (s Set) Has(n graph.Node) bool {
+	_, ok := s[n.ID()]
+	return ok
+}
+
+// Clear returns an empty set, possibly using the same backing store.
+// Clear is not provided as a method since there is no way to replace
+// the calling value if clearing is performed by a make(set). Clear
+// should never be called without keeping the returned value.
+func Clear(s Set) Set {
+	if len(s) == 0 {
+		return s
+	}
+
+	return make(Set)
+}
+
+// Copy performs a perfect copy from s1 to dst (meaning the sets will
+// be equal).
+func (dst Set) Copy(src Set) Set {
+	if Same(src, dst) {
+		return dst
+	}
+
+	if len(dst) > 0 {
+		dst = make(Set, len(src))
+	}
+
+	for e, n := range src {
+		dst[e] = n
+	}
+
+	return dst
+}
+
+// Equal reports set equality between the parameters. Sets are equal if
+// and only if they have the same elements.
+func Equal(s1, s2 Set) bool {
+	if Same(s1, s2) {
+		return true
+	}
+
+	if len(s1) != len(s2) {
+		return false
+	}
+
+	for e := range s1 {
+		if _, ok := s2[e]; !ok {
+			return false
+		}
+	}
+
+	return true
+}
+
+// Union takes the union of s1 and s2, and stores it in dst.
+//
+// The union of two sets, s1 and s2, is the set containing all the
+// elements of each, for instance:
+//
+//     {a,b,c} UNION {d,e,f} = {a,b,c,d,e,f}
+//
+// Since sets may not have repetition, unions of two sets that overlap
+// do not contain repeat elements, that is:
+//
+//     {a,b,c} UNION {b,c,d} = {a,b,c,d}
+//
+func (dst Set) Union(s1, s2 Set) Set {
+	if Same(s1, s2) {
+		return dst.Copy(s1)
+	}
+
+	if !Same(s1, dst) && !Same(s2, dst) {
+		dst = Clear(dst)
+	}
+
+	if !Same(dst, s1) {
+		for e, n := range s1 {
+			dst[e] = n
+		}
+	}
+
+	if !Same(dst, s2) {
+		for e, n := range s2 {
+			dst[e] = n
+		}
+	}
+
+	return dst
+}
+
+// Intersect takes the intersection of s1 and s2, and stores it in dst.
+//
+// The intersection of two sets, s1 and s2, is the set containing all
+// the elements shared between the two sets, for instance:
+//
+//     {a,b,c} INTERSECT {b,c,d} = {b,c}
+//
+// The intersection between a set and itself is itself, and thus
+// effectively a copy operation:
+//
+//     {a,b,c} INTERSECT {a,b,c} = {a,b,c}
+//
+// The intersection between two sets that share no elements is the empty
+// set:
+//
+//     {a,b,c} INTERSECT {d,e,f} = {}
+//
+func (dst Set) Intersect(s1, s2 Set) Set {
+	var swap Set
+
+	if Same(s1, s2) {
+		return dst.Copy(s1)
+	}
+	if Same(s1, dst) {
+		swap = s2
+	} else if Same(s2, dst) {
+		swap = s1
+	} else {
+		dst = Clear(dst)
+
+		if len(s1) > len(s2) {
+			s1, s2 = s2, s1
+		}
+
+		for e, n := range s1 {
+			if _, ok := s2[e]; ok {
+				dst[e] = n
+			}
+		}
+
+		return dst
+	}
+
+	for e := range dst {
+		if _, ok := swap[e]; !ok {
+			delete(dst, e)
+		}
+	}
+
+	return dst
+}
diff --git a/Godeps/_workspace/src/github.com/gonum/graph/inteernal/set_test.go b/Godeps/_workspace/src/github.com/gonum/graph/inteernal/set_test.go
new file mode 100644
index 0000000..fb39620
--- /dev/null
+++ b/Godeps/_workspace/src/github.com/gonum/graph/inteernal/set_test.go
@@ -0,0 +1,413 @@
+// Copyright ©2014 The gonum Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+package internal
+
+import "testing"
+
+type node int
+
+func (n node) ID() int { return int(n) }
+
+// count reports the number of elements stored in the set.
+func (s Set) count() int {
+	return len(s)
+}
+
+// TestSame tests the assumption that pointer equality via unsafe conversion
+// of a map[int]struct{} to uintptr is a valid test for perfect identity between
+// set values. If any of the tests in TestSame fail, the package is broken and same
+// must be reimplemented to conform to the runtime map implementation. The relevant
+// code to look at (at least for gc) is in runtime/hashmap.{h,goc}.
+func TestSame(t *testing.T) {
+	var (
+		a = make(Set)
+		b = make(Set)
+		c = a
+	)
+
+	if Same(a, b) {
+		t.Error("Independently created sets test as same")
+	}
+	if !Same(a, c) {
+		t.Error("Set copy and original test as not same.")
+	}
+	a.Add(node(1))
+	if !Same(a, c) {
+		t.Error("Set copy and original test as not same after addition.")
+	}
+	if !Same(nil, nil) {
+		t.Error("nil sets test as not same.")
+	}
+	if Same(b, nil) {
+		t.Error("nil and empty sets test as same.")
+	}
+}
+
+func TestAdd(t *testing.T) {
+	s := make(Set)
+	if s == nil {
+		t.Fatal("Set cannot be created successfully")
+	}
+
+	if s.count() != 0 {
+		t.Error("Set somehow contains new elements upon creation")
+	}
+
+	s.Add(node(1))
+	s.Add(node(3))
+	s.Add(node(5))
+
+	if s.count() != 3 {
+		t.Error("Incorrect number of set elements after adding")
+	}
+
+	if !s.Has(node(1)) || !s.Has(node(3)) || !s.Has(node(5)) {
+		t.Error("Set doesn't contain element that was added")
+	}
+
+	s.Add(node(1))
+
+	if s.count() > 3 {
+		t.Error("Set double-adds element (element not unique)")
+	} else if s.count() < 3 {
+		t.Error("Set double-add lowered len")
+	}
+
+	if !s.Has(node(1)) {
+		t.Error("Set doesn't contain double-added element")
+	}
+
+	if !s.Has(node(3)) || !s.Has(node(5)) {
+		t.Error("Set removes element on double-add")
+	}
+
+	for e, n := range s {
+		if e != n.ID() {
+			t.Error("Element ID did not match key: %d != %d", e, n.ID())
+		}
+	}
+}
+
+func TestRemove(t *testing.T) {
+	s := make(Set)
+
+	s.Add(node(1))
+	s.Add(node(3))
+	s.Add(node(5))
+
+	s.Remove(node(1))
+
+	if s.count() != 2 {
+		t.Error("Incorrect number of set elements after removing an element")
+	}
+
+	if s.Has(node(1)) {
+		t.Error("Element present after removal")
+	}
+
+	if !s.Has(node(3)) || !s.Has(node(5)) {
+		t.Error("Set remove removed wrong element")
+	}
+
+	s.Remove(node(1))
+
+	if s.count() != 2 || s.Has(node(1)) {
+		t.Error("Double set remove does something strange")
+	}
+
+	s.Add(node(1))
+
+	if s.count() != 3 || !s.Has(node(1)) {
+		t.Error("Cannot add element after removal")
+	}
+}
+
+func TestClear(t *testing.T) {
+	s := make(Set)
+
+	s.Add(node(8))
+	s.Add(node(9))
+	s.Add(node(10))
+
+	s = Clear(s)
+
+	if s.count() != 0 {
+		t.Error("Clear did not properly reset set to size 0")
+	}
+}
+
+func TestSelfEqual(t *testing.T) {
+	s := make(Set)
+
+	if !Equal(s, s) {
+		t.Error("Set is not equal to itself")
+	}
+
+	s.Add(node(1))
+
+	if !Equal(s, s) {
+		t.Error("Set ceases self equality after adding element")
+	}
+}
+
+func TestEqual(t *testing.T) {
+	s1 := make(Set)
+	s2 := make(Set)
+
+	if !Equal(s1, s2) {
+		t.Error("Two different empty sets not equal")
+	}
+
+	s1.Add(node(1))
+	if Equal(s1, s2) {
+		t.Error("Two different sets with different elements not equal")
+	}
+
+	s2.Add(node(1))
+	if !Equal(s1, s2) {
+		t.Error("Two sets with same element not equal")
+	}
+}
+
+func TestCopy(t *testing.T) {
+	s1 := make(Set)
+	s2 := make(Set)
+
+	s1.Add(node(1))
+	s1.Add(node(2))
+	s1.Add(node(3))
+
+	s2.Copy(s1)
+
+	if !Equal(s1, s2) {
+		t.Fatalf("Two sets not equal after copy")
+	}
+
+	s2.Remove(node(1))
+
+	if Equal(s1, s2) {
+		t.Errorf("Mutating one set mutated another after copy")
+	}
+}
+
+func TestSelfCopy(t *testing.T) {
+	s1 := make(Set)
+
+	s1.Add(node(1))
+	s1.Add(node(2))
+
+	s1.Copy(s1)
+
+	if s1.count() != 2 {
+		t.Error("Something strange happened when copying into self")
+	}
+}
+
+func TestUnionSame(t *testing.T) {
+	s1 := make(Set)
+	s2 := make(Set)
+	s3 := make(Set)
+
+	s1.Add(node(1))
+	s1.Add(node(2))
+
+	s2.Add(node(1))
+	s2.Add(node(2))
+
+	s3.Union(s1, s2)
+
+	if s3.count() != 2 {
+		t.Error("Union of same sets yields set with wrong len")
+	}
+
+	if !s3.Has(node(1)) || !s3.Has(node(2)) {
+		t.Error("Union of same sets yields wrong elements")
+	}
+
+	for i, s := range []Set{s1, s2, s3} {
+		for e, n := range s {
+			if e != n.ID() {
+				t.Error("Element ID did not match key in s%d: %d != %d", i+1, e, n.ID())
+			}
+		}
+	}
+}
+
+func TestUnionDiff(t *testing.T) {
+	s1 := make(Set)
+	s2 := make(Set)
+	s3 := make(Set)
+
+	s1.Add(node(1))
+	s1.Add(node(2))
+
+	s2.Add(node(3))
+
+	s3.Union(s1, s2)
+
+	if s3.count() != 3 {
+		t.Error("Union of different sets yields set with wrong len")
+	}
+
+	if !s3.Has(node(1)) || !s3.Has(node(2)) || !s3.Has(node(3)) {
+		t.Error("Union of different sets yields set with wrong elements")
+	}
+
+	if s1.Has(node(3)) || !s1.Has(node(2)) || !s1.Has(node(1)) || s1.count() != 2 {
+		t.Error("Union of sets mutates non-destination set (argument 1)")
+	}
+
+	if !s2.Has(node(3)) || s2.Has(node(1)) || s2.Has(node(2)) || s2.count() != 1 {
+		t.Error("Union of sets mutates non-destination set (argument 2)")
+	}
+
+	for i, s := range []Set{s1, s2, s3} {
+		for e, n := range s {
+			if e != n.ID() {
+				t.Error("Element ID did not match key in s%d: %d != %d", i+1, e, n.ID())
+			}
+		}
+	}
+}
+
+func TestUnionOverlapping(t *testing.T) {
+	s1 := make(Set)
+	s2 := make(Set)
+	s3 := make(Set)
+
+	s1.Add(node(1))
+	s1.Add(node(2))
+
+	s2.Add(node(2))
+	s2.Add(node(3))
+
+	s3.Union(s1, s2)
+
+	if s3.count() != 3 {
+		t.Error("Union of overlapping sets yields set with wrong len")
+	}
+
+	if !s3.Has(node(1)) || !s3.Has(node(2)) || !s3.Has(node(3)) {
+		t.Error("Union of overlapping sets yields set with wrong elements")
+	}
+
+	if s1.Has(node(3)) || !s1.Has(node(2)) || !s1.Has(node(1)) || s1.count() != 2 {
+		t.Error("Union of sets mutates non-destination set (argument 1)")
+	}
+
+	if !s2.Has(node(3)) || s2.Has(node(1)) || !s2.Has(node(2)) || s2.count() != 2 {
+		t.Error("Union of sets mutates non-destination set (argument 2)")
+	}
+
+	for i, s := range []Set{s1, s2, s3} {
+		for e, n := range s {
+			if e != n.ID() {
+				t.Error("Element ID did not match key in s%d: %d != %d", i+1, e, n.ID())
+			}
+		}
+	}
+}
+
+func TestIntersectSame(t *testing.T) {
+	s1 := make(Set)
+	s2 := make(Set)
+	s3 := make(Set)
+
+	s1.Add(node(2))
+	s1.Add(node(3))
+
+	s2.Add(node(2))
+	s2.Add(node(3))
+
+	s3.Intersect(s1, s2)
+
+	if card := s3.count(); card != 2 {
+		t.Errorf("Intersection of identical sets yields set of wrong len %d", card)
+	}
+
+	if !s3.Has(node(2)) || !s3.Has(node(3)) {
+		t.Error("Intersection of identical sets yields set of wrong elements")
+	}
+
+	for i, s := range []Set{s1, s2, s3} {
+		for e, n := range s {
+			if e != n.ID() {
+				t.Error("Element ID did not match key in s%d: %d != %d", i+1, e, n.ID())
+			}
+		}
+	}
+}
+
+func TestIntersectDiff(t *testing.T) {
+	s1 := make(Set)
+	s2 := make(Set)
+	s3 := make(Set)
+
+	s1.Add(node(2))
+	s1.Add(node(3))
+
+	s2.Add(node(1))
+	s2.Add(node(4))
+
+	s3.Intersect(s1, s2)
+
+	if card := s3.count(); card != 0 {
+		t.Errorf("Intersection of different yields non-empty set %d", card)
+	}
+
+	if !s1.Has(node(2)) || !s1.Has(node(3)) || s1.Has(node(1)) || s1.Has(node(4)) || s1.count() != 2 {
+		t.Error("Intersection of sets mutates non-destination set (argument 1)")
+	}
+
+	if s2.Has(node(2)) || s2.Has(node(3)) || !s2.Has(node(1)) || !s2.Has(node(4)) || s2.count() != 2 {
+		t.Error("Intersection of sets mutates non-destination set (argument 1)")
+	}
+
+	for i, s := range []Set{s1, s2, s3} {
+		for e, n := range s {
+			if e != n.ID() {
+				t.Error("Element ID did not match key in s%d: %d != %d", i+1, e, n.ID())
+			}
+		}
+	}
+}
+
+func TestIntersectOverlapping(t *testing.T) {
+	s1 := make(Set)
+	s2 := make(Set)
+	s3 := make(Set)
+
+	s1.Add(node(2))
+	s1.Add(node(3))
+
+	s2.Add(node(3))
+	s2.Add(node(4))
+
+	s3.Intersect(s1, s2)
+
+	if card := s3.count(); card != 1 {
+		t.Errorf("Intersection of overlapping sets yields set of incorrect len %d", card)
+	}
+
+	if !s3.Has(node(3)) {
+		t.Errorf("Intersection of overlapping sets yields set with wrong element")
+	}
+
+	if !s1.Has(node(2)) || !s1.Has(node(3)) || s1.Has(node(4)) || s1.count() != 2 {
+		t.Error("Intersection of sets mutates non-destination set (argument 1)")
+	}
+
+	if s2.Has(node(2)) || !s2.Has(node(3)) || !s2.Has(node(4)) || s2.count() != 2 {
+		t.Error("Intersection of sets mutates non-destination set (argument 1)")
+	}
+
+	for i, s := range []Set{s1, s2, s3} {
+		for e, n := range s {
+			if e != n.ID() {
+				t.Error("Element ID did not match key in s%d: %d != %d", i+1, e, n.ID())
+			}
+		}
+	}
+}
diff --git a/Godeps/_workspace/src/github.com/gonum/graph/inteernal/sort.go b/Godeps/_workspace/src/github.com/gonum/graph/inteernal/sort.go
new file mode 100644
index 0000000..3bfee0f
--- /dev/null
+++ b/Godeps/_workspace/src/github.com/gonum/graph/inteernal/sort.go
@@ -0,0 +1,28 @@
+// Copyright ©2015 The gonum Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+package internal
+
+// BySliceValues implements the sort.Interface sorting a slice of
+// []int lexically by the values of the []int.
+type BySliceValues [][]int
+
+func (c BySliceValues) Len() int { return len(c) }
+func (c BySliceValues) Less(i, j int) bool {
+	a, b := c[i], c[j]
+	l := len(a)
+	if len(b) < l {
+		l = len(b)
+	}
+	for k, v := range a[:l] {
+		if v < b[k] {
+			return true
+		}
+		if v > b[k] {
+			return false
+		}
+	}
+	return len(a) < len(b)
+}
+func (c BySliceValues) Swap(i, j int) { c[i], c[j] = c[j], c[i] }
diff --git a/Godeps/_workspace/src/github.com/gonum/graph/internal/linear.go b/Godeps/_workspace/src/github.com/gonum/graph/internal/linear.go
deleted file mode 100644
index 3d64de9..0000000
--- a/Godeps/_workspace/src/github.com/gonum/graph/internal/linear.go
+++ /dev/null
@@ -1,73 +0,0 @@
-// Copyright ©2015 The gonum Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style
-// license that can be found in the LICENSE file.
-
-package internal
-
-import (
-	"github.com/gonum/graph"
-)
-
-// NodeStack implements a LIFO stack of graph.Node.
-type NodeStack []graph.Node
-
-// Len returns the number of graph.Nodes on the stack.
-func (s *NodeStack) Len() int { return len(*s) }
-
-// Pop returns the last graph.Node on the stack and removes it
-// from the stack.
-func (s *NodeStack) Pop() graph.Node {
-	v := *s
-	v, n := v[:len(v)-1], v[len(v)-1]
-	*s = v
-	return n
-}
-
-// Push adds the node n to the stack at the last position.
-func (s *NodeStack) Push(n graph.Node) { *s = append(*s, n) }
-
-// NodeQueue implements a FIFO queue.
-type NodeQueue struct {
-	head int
-	data []graph.Node
-}
-
-// Len returns the number of graph.Nodes in the queue.
-func (q *NodeQueue) Len() int { return len(q.data) - q.head }
-
-// Enqueue adds the node n to the back of the queue.
-func (q *NodeQueue) Enqueue(n graph.Node) {
-	if len(q.data) == cap(q.data) && q.head > 0 {
-		l := q.Len()
-		copy(q.data, q.data[q.head:])
-		q.head = 0
-		q.data = append(q.data[:l], n)
-	} else {
-		q.data = append(q.data, n)
-	}
-}
-
-// Dequeue returns the graph.Node at the front of the queue and
-// removes it from the queue.
-func (q *NodeQueue) Dequeue() graph.Node {
-	if q.Len() == 0 {
-		panic("queue: empty queue")
-	}
-
-	var n graph.Node
-	n, q.data[q.head] = q.data[q.head], nil
-	q.head++
-
-	if q.Len() == 0 {
-		q.head = 0
-		q.data = q.data[:0]
-	}
-
-	return n
-}
-
-// Reset clears the queue for reuse.
-func (q *NodeQueue) Reset() {
-	q.head = 0
-	q.data = q.data[:0]
-}
diff --git a/Godeps/_workspace/src/github.com/gonum/graph/internal/set.go b/Godeps/_workspace/src/github.com/gonum/graph/internal/set.go
deleted file mode 100644
index 3ad1bc8..0000000
--- a/Godeps/_workspace/src/github.com/gonum/graph/internal/set.go
+++ /dev/null
@@ -1,211 +0,0 @@
-// Copyright ©2014 The gonum Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style
-// license that can be found in the LICENSE file.
-
-package internal
-
-import (
-	"unsafe"
-
-	"github.com/gonum/graph"
-)
-
-// IntSet is a set of integer identifiers.
-type IntSet map[int]struct{}
-
-// The simple accessor methods for Set are provided to allow ease of
-// implementation change should the need arise.
-
-// Add inserts an element into the set.
-func (s IntSet) Add(e int) {
-	s[e] = struct{}{}
-}
-
-// Has reports the existence of the element in the set.
-func (s IntSet) Has(e int) bool {
-	_, ok := s[e]
-	return ok
-}
-
-// Remove deletes the specified element from the set.
-func (s IntSet) Remove(e int) {
-	delete(s, e)
-}
-
-// Count reports the number of elements stored in the set.
-func (s IntSet) Count() int {
-	return len(s)
-}
-
-// Same determines whether two sets are backed by the same store. In the
-// current implementation using hash maps it makes use of the fact that
-// hash maps (at least in the gc implementation) are passed as a pointer
-// to a runtime Hmap struct.
-//
-// A map is not seen by the runtime as a pointer though, so we cannot
-// directly compare the sets converted to unsafe.Pointer and need to take
-// the sets' addressed and dereference them as pointers to some comparable
-// type.
-func Same(s1, s2 Set) bool {
-	return *(*uintptr)(unsafe.Pointer(&s1)) == *(*uintptr)(unsafe.Pointer(&s2))
-}
-
-// A set is a set of nodes keyed in their integer identifiers.
-type Set map[int]graph.Node
-
-// The simple accessor methods for Set are provided to allow ease of
-// implementation change should the need arise.
-
-// Add inserts an element into the set.
-func (s Set) Add(n graph.Node) {
-	s[n.ID()] = n
-}
-
-// Remove deletes the specified element from the set.
-func (s Set) Remove(e graph.Node) {
-	delete(s, e.ID())
-}
-
-// Has reports the existence of the element in the set.
-func (s Set) Has(n graph.Node) bool {
-	_, ok := s[n.ID()]
-	return ok
-}
-
-// Clear returns an empty set, possibly using the same backing store.
-// Clear is not provided as a method since there is no way to replace
-// the calling value if clearing is performed by a make(set). Clear
-// should never be called without keeping the returned value.
-func Clear(s Set) Set {
-	if len(s) == 0 {
-		return s
-	}
-
-	return make(Set)
-}
-
-// Copy performs a perfect copy from s1 to dst (meaning the sets will
-// be equal).
-func (dst Set) Copy(src Set) Set {
-	if Same(src, dst) {
-		return dst
-	}
-
-	if len(dst) > 0 {
-		dst = make(Set, len(src))
-	}
-
-	for e, n := range src {
-		dst[e] = n
-	}
-
-	return dst
-}
-
-// Equal reports set equality between the parameters. Sets are equal if
-// and only if they have the same elements.
-func Equal(s1, s2 Set) bool {
-	if Same(s1, s2) {
-		return true
-	}
-
-	if len(s1) != len(s2) {
-		return false
-	}
-
-	for e := range s1 {
-		if _, ok := s2[e]; !ok {
-			return false
-		}
-	}
-
-	return true
-}
-
-// Union takes the union of s1 and s2, and stores it in dst.
-//
-// The union of two sets, s1 and s2, is the set containing all the
-// elements of each, for instance:
-//
-//     {a,b,c} UNION {d,e,f} = {a,b,c,d,e,f}
-//
-// Since sets may not have repetition, unions of two sets that overlap
-// do not contain repeat elements, that is:
-//
-//     {a,b,c} UNION {b,c,d} = {a,b,c,d}
-//
-func (dst Set) Union(s1, s2 Set) Set {
-	if Same(s1, s2) {
-		return dst.Copy(s1)
-	}
-
-	if !Same(s1, dst) && !Same(s2, dst) {
-		dst = Clear(dst)
-	}
-
-	if !Same(dst, s1) {
-		for e, n := range s1 {
-			dst[e] = n
-		}
-	}
-
-	if !Same(dst, s2) {
-		for e, n := range s2 {
-			dst[e] = n
-		}
-	}
-
-	return dst
-}
-
-// Intersect takes the intersection of s1 and s2, and stores it in dst.
-//
-// The intersection of two sets, s1 and s2, is the set containing all
-// the elements shared between the two sets, for instance:
-//
-//     {a,b,c} INTERSECT {b,c,d} = {b,c}
-//
-// The intersection between a set and itself is itself, and thus
-// effectively a copy operation:
-//
-//     {a,b,c} INTERSECT {a,b,c} = {a,b,c}
-//
-// The intersection between two sets that share no elements is the empty
-// set:
-//
-//     {a,b,c} INTERSECT {d,e,f} = {}
-//
-func (dst Set) Intersect(s1, s2 Set) Set {
-	var swap Set
-
-	if Same(s1, s2) {
-		return dst.Copy(s1)
-	}
-	if Same(s1, dst) {
-		swap = s2
-	} else if Same(s2, dst) {
-		swap = s1
-	} else {
-		dst = Clear(dst)
-
-		if len(s1) > len(s2) {
-			s1, s2 = s2, s1
-		}
-
-		for e, n := range s1 {
-			if _, ok := s2[e]; ok {
-				dst[e] = n
-			}
-		}
-
-		return dst
-	}
-
-	for e := range dst {
-		if _, ok := swap[e]; !ok {
-			delete(dst, e)
-		}
-	}
-
-	return dst
-}
diff --git a/Godeps/_workspace/src/github.com/gonum/graph/internal/set_test.go b/Godeps/_workspace/src/github.com/gonum/graph/internal/set_test.go
deleted file mode 100644
index fb39620..0000000
--- a/Godeps/_workspace/src/github.com/gonum/graph/internal/set_test.go
+++ /dev/null
@@ -1,413 +0,0 @@
-// Copyright ©2014 The gonum Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style
-// license that can be found in the LICENSE file.
-
-package internal
-
-import "testing"
-
-type node int
-
-func (n node) ID() int { return int(n) }
-
-// count reports the number of elements stored in the set.
-func (s Set) count() int {
-	return len(s)
-}
-
-// TestSame tests the assumption that pointer equality via unsafe conversion
-// of a map[int]struct{} to uintptr is a valid test for perfect identity between
-// set values. If any of the tests in TestSame fail, the package is broken and same
-// must be reimplemented to conform to the runtime map implementation. The relevant
-// code to look at (at least for gc) is in runtime/hashmap.{h,goc}.
-func TestSame(t *testing.T) {
-	var (
-		a = make(Set)
-		b = make(Set)
-		c = a
-	)
-
-	if Same(a, b) {
-		t.Error("Independently created sets test as same")
-	}
-	if !Same(a, c) {
-		t.Error("Set copy and original test as not same.")
-	}
-	a.Add(node(1))
-	if !Same(a, c) {
-		t.Error("Set copy and original test as not same after addition.")
-	}
-	if !Same(nil, nil) {
-		t.Error("nil sets test as not same.")
-	}
-	if Same(b, nil) {
-		t.Error("nil and empty sets test as same.")
-	}
-}
-
-func TestAdd(t *testing.T) {
-	s := make(Set)
-	if s == nil {
-		t.Fatal("Set cannot be created successfully")
-	}
-
-	if s.count() != 0 {
-		t.Error("Set somehow contains new elements upon creation")
-	}
-
-	s.Add(node(1))
-	s.Add(node(3))
-	s.Add(node(5))
-
-	if s.count() != 3 {
-		t.Error("Incorrect number of set elements after adding")
-	}
-
-	if !s.Has(node(1)) || !s.Has(node(3)) || !s.Has(node(5)) {
-		t.Error("Set doesn't contain element that was added")
-	}
-
-	s.Add(node(1))
-
-	if s.count() > 3 {
-		t.Error("Set double-adds element (element not unique)")
-	} else if s.count() < 3 {
-		t.Error("Set double-add lowered len")
-	}
-
-	if !s.Has(node(1)) {
-		t.Error("Set doesn't contain double-added element")
-	}
-
-	if !s.Has(node(3)) || !s.Has(node(5)) {
-		t.Error("Set removes element on double-add")
-	}
-
-	for e, n := range s {
-		if e != n.ID() {
-			t.Error("Element ID did not match key: %d != %d", e, n.ID())
-		}
-	}
-}
-
-func TestRemove(t *testing.T) {
-	s := make(Set)
-
-	s.Add(node(1))
-	s.Add(node(3))
-	s.Add(node(5))
-
-	s.Remove(node(1))
-
-	if s.count() != 2 {
-		t.Error("Incorrect number of set elements after removing an element")
-	}
-
-	if s.Has(node(1)) {
-		t.Error("Element present after removal")
-	}
-
-	if !s.Has(node(3)) || !s.Has(node(5)) {
-		t.Error("Set remove removed wrong element")
-	}
-
-	s.Remove(node(1))
-
-	if s.count() != 2 || s.Has(node(1)) {
-		t.Error("Double set remove does something strange")
-	}
-
-	s.Add(node(1))
-
-	if s.count() != 3 || !s.Has(node(1)) {
-		t.Error("Cannot add element after removal")
-	}
-}
-
-func TestClear(t *testing.T) {
-	s := make(Set)
-
-	s.Add(node(8))
-	s.Add(node(9))
-	s.Add(node(10))
-
-	s = Clear(s)
-
-	if s.count() != 0 {
-		t.Error("Clear did not properly reset set to size 0")
-	}
-}
-
-func TestSelfEqual(t *testing.T) {
-	s := make(Set)
-
-	if !Equal(s, s) {
-		t.Error("Set is not equal to itself")
-	}
-
-	s.Add(node(1))
-
-	if !Equal(s, s) {
-		t.Error("Set ceases self equality after adding element")
-	}
-}
-
-func TestEqual(t *testing.T) {
-	s1 := make(Set)
-	s2 := make(Set)
-
-	if !Equal(s1, s2) {
-		t.Error("Two different empty sets not equal")
-	}
-
-	s1.Add(node(1))
-	if Equal(s1, s2) {
-		t.Error("Two different sets with different elements not equal")
-	}
-
-	s2.Add(node(1))
-	if !Equal(s1, s2) {
-		t.Error("Two sets with same element not equal")
-	}
-}
-
-func TestCopy(t *testing.T) {
-	s1 := make(Set)
-	s2 := make(Set)
-
-	s1.Add(node(1))
-	s1.Add(node(2))
-	s1.Add(node(3))
-
-	s2.Copy(s1)
-
-	if !Equal(s1, s2) {
-		t.Fatalf("Two sets not equal after copy")
-	}
-
-	s2.Remove(node(1))
-
-	if Equal(s1, s2) {
-		t.Errorf("Mutating one set mutated another after copy")
-	}
-}
-
-func TestSelfCopy(t *testing.T) {
-	s1 := make(Set)
-
-	s1.Add(node(1))
-	s1.Add(node(2))
-
-	s1.Copy(s1)
-
-	if s1.count() != 2 {
-		t.Error("Something strange happened when copying into self")
-	}
-}
-
-func TestUnionSame(t *testing.T) {
-	s1 := make(Set)
-	s2 := make(Set)
-	s3 := make(Set)
-
-	s1.Add(node(1))
-	s1.Add(node(2))
-
-	s2.Add(node(1))
-	s2.Add(node(2))
-
-	s3.Union(s1, s2)
-
-	if s3.count() != 2 {
-		t.Error("Union of same sets yields set with wrong len")
-	}
-
-	if !s3.Has(node(1)) || !s3.Has(node(2)) {
-		t.Error("Union of same sets yields wrong elements")
-	}
-
-	for i, s := range []Set{s1, s2, s3} {
-		for e, n := range s {
-			if e != n.ID() {
-				t.Error("Element ID did not match key in s%d: %d != %d", i+1, e, n.ID())
-			}
-		}
-	}
-}
-
-func TestUnionDiff(t *testing.T) {
-	s1 := make(Set)
-	s2 := make(Set)
-	s3 := make(Set)
-
-	s1.Add(node(1))
-	s1.Add(node(2))
-
-	s2.Add(node(3))
-
-	s3.Union(s1, s2)
-
-	if s3.count() != 3 {
-		t.Error("Union of different sets yields set with wrong len")
-	}
-
-	if !s3.Has(node(1)) || !s3.Has(node(2)) || !s3.Has(node(3)) {
-		t.Error("Union of different sets yields set with wrong elements")
-	}
-
-	if s1.Has(node(3)) || !s1.Has(node(2)) || !s1.Has(node(1)) || s1.count() != 2 {
-		t.Error("Union of sets mutates non-destination set (argument 1)")
-	}
-
-	if !s2.Has(node(3)) || s2.Has(node(1)) || s2.Has(node(2)) || s2.count() != 1 {
-		t.Error("Union of sets mutates non-destination set (argument 2)")
-	}
-
-	for i, s := range []Set{s1, s2, s3} {
-		for e, n := range s {
-			if e != n.ID() {
-				t.Error("Element ID did not match key in s%d: %d != %d", i+1, e, n.ID())
-			}
-		}
-	}
-}
-
-func TestUnionOverlapping(t *testing.T) {
-	s1 := make(Set)
-	s2 := make(Set)
-	s3 := make(Set)
-
-	s1.Add(node(1))
-	s1.Add(node(2))
-
-	s2.Add(node(2))
-	s2.Add(node(3))
-
-	s3.Union(s1, s2)
-
-	if s3.count() != 3 {
-		t.Error("Union of overlapping sets yields set with wrong len")
-	}
-
-	if !s3.Has(node(1)) || !s3.Has(node(2)) || !s3.Has(node(3)) {
-		t.Error("Union of overlapping sets yields set with wrong elements")
-	}
-
-	if s1.Has(node(3)) || !s1.Has(node(2)) || !s1.Has(node(1)) || s1.count() != 2 {
-		t.Error("Union of sets mutates non-destination set (argument 1)")
-	}
-
-	if !s2.Has(node(3)) || s2.Has(node(1)) || !s2.Has(node(2)) || s2.count() != 2 {
-		t.Error("Union of sets mutates non-destination set (argument 2)")
-	}
-
-	for i, s := range []Set{s1, s2, s3} {
-		for e, n := range s {
-			if e != n.ID() {
-				t.Error("Element ID did not match key in s%d: %d != %d", i+1, e, n.ID())
-			}
-		}
-	}
-}
-
-func TestIntersectSame(t *testing.T) {
-	s1 := make(Set)
-	s2 := make(Set)
-	s3 := make(Set)
-
-	s1.Add(node(2))
-	s1.Add(node(3))
-
-	s2.Add(node(2))
-	s2.Add(node(3))
-
-	s3.Intersect(s1, s2)
-
-	if card := s3.count(); card != 2 {
-		t.Errorf("Intersection of identical sets yields set of wrong len %d", card)
-	}
-
-	if !s3.Has(node(2)) || !s3.Has(node(3)) {
-		t.Error("Intersection of identical sets yields set of wrong elements")
-	}
-
-	for i, s := range []Set{s1, s2, s3} {
-		for e, n := range s {
-			if e != n.ID() {
-				t.Error("Element ID did not match key in s%d: %d != %d", i+1, e, n.ID())
-			}
-		}
-	}
-}
-
-func TestIntersectDiff(t *testing.T) {
-	s1 := make(Set)
-	s2 := make(Set)
-	s3 := make(Set)
-
-	s1.Add(node(2))
-	s1.Add(node(3))
-
-	s2.Add(node(1))
-	s2.Add(node(4))
-
-	s3.Intersect(s1, s2)
-
-	if card := s3.count(); card != 0 {
-		t.Errorf("Intersection of different yields non-empty set %d", card)
-	}
-
-	if !s1.Has(node(2)) || !s1.Has(node(3)) || s1.Has(node(1)) || s1.Has(node(4)) || s1.count() != 2 {
-		t.Error("Intersection of sets mutates non-destination set (argument 1)")
-	}
-
-	if s2.Has(node(2)) || s2.Has(node(3)) || !s2.Has(node(1)) || !s2.Has(node(4)) || s2.count() != 2 {
-		t.Error("Intersection of sets mutates non-destination set (argument 1)")
-	}
-
-	for i, s := range []Set{s1, s2, s3} {
-		for e, n := range s {
-			if e != n.ID() {
-				t.Error("Element ID did not match key in s%d: %d != %d", i+1, e, n.ID())
-			}
-		}
-	}
-}
-
-func TestIntersectOverlapping(t *testing.T) {
-	s1 := make(Set)
-	s2 := make(Set)
-	s3 := make(Set)
-
-	s1.Add(node(2))
-	s1.Add(node(3))
-
-	s2.Add(node(3))
-	s2.Add(node(4))
-
-	s3.Intersect(s1, s2)
-
-	if card := s3.count(); card != 1 {
-		t.Errorf("Intersection of overlapping sets yields set of incorrect len %d", card)
-	}
-
-	if !s3.Has(node(3)) {
-		t.Errorf("Intersection of overlapping sets yields set with wrong element")
-	}
-
-	if !s1.Has(node(2)) || !s1.Has(node(3)) || s1.Has(node(4)) || s1.count() != 2 {
-		t.Error("Intersection of sets mutates non-destination set (argument 1)")
-	}
-
-	if s2.Has(node(2)) || !s2.Has(node(3)) || !s2.Has(node(4)) || s2.count() != 2 {
-		t.Error("Intersection of sets mutates non-destination set (argument 1)")
-	}
-
-	for i, s := range []Set{s1, s2, s3} {
-		for e, n := range s {
-			if e != n.ID() {
-				t.Error("Element ID did not match key in s%d: %d != %d", i+1, e, n.ID())
-			}
-		}
-	}
-}
diff --git a/Godeps/_workspace/src/github.com/gonum/graph/internal/sort.go b/Godeps/_workspace/src/github.com/gonum/graph/internal/sort.go
deleted file mode 100644
index 3bfee0f..0000000
--- a/Godeps/_workspace/src/github.com/gonum/graph/internal/sort.go
+++ /dev/null
@@ -1,28 +0,0 @@
-// Copyright ©2015 The gonum Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style
-// license that can be found in the LICENSE file.
-
-package internal
-
-// BySliceValues implements the sort.Interface sorting a slice of
-// []int lexically by the values of the []int.
-type BySliceValues [][]int
-
-func (c BySliceValues) Len() int { return len(c) }
-func (c BySliceValues) Less(i, j int) bool {
-	a, b := c[i], c[j]
-	l := len(a)
-	if len(b) < l {
-		l = len(b)
-	}
-	for k, v := range a[:l] {
-		if v < b[k] {
-			return true
-		}
-		if v > b[k] {
-			return false
-		}
-	}
-	return len(a) < len(b)
-}
-func (c BySliceValues) Swap(i, j int) { c[i], c[j] = c[j], c[i] }
diff --git a/Godeps/_workspace/src/github.com/gonum/graph/network/betweenness.go b/Godeps/_workspace/src/github.com/gonum/graph/network/betweenness.go
index ad16732..dbe216e 100644
--- a/Godeps/_workspace/src/github.com/gonum/graph/network/betweenness.go
+++ b/Godeps/_workspace/src/github.com/gonum/graph/network/betweenness.go
@@ -8,7 +8,7 @@ import (
 	"math"
 
 	"github.com/gonum/graph"
-	"github.com/gonum/graph/internal"
+	"github.com/gonum/graph/inteernal"
 	"github.com/gonum/graph/path"
 )
 
diff --git a/Godeps/_workspace/src/github.com/gonum/graph/path/a_star.go b/Godeps/_workspace/src/github.com/gonum/graph/path/a_star.go
index b41d194..d742cff 100644
--- a/Godeps/_workspace/src/github.com/gonum/graph/path/a_star.go
+++ b/Godeps/_workspace/src/github.com/gonum/graph/path/a_star.go
@@ -8,7 +8,7 @@ import (
 	"container/heap"
 
 	"github.com/gonum/graph"
-	"github.com/gonum/graph/internal"
+	"github.com/gonum/graph/inteernal"
 )
 
 // Heuristic returns an estimate of the cost of travelling between two nodes.
diff --git a/Godeps/_workspace/src/github.com/gonum/graph/path/control_flow.go b/Godeps/_workspace/src/github.com/gonum/graph/path/control_flow.go
index 219226d..9bebf2c 100644
--- a/Godeps/_workspace/src/github.com/gonum/graph/path/control_flow.go
+++ b/Godeps/_workspace/src/github.com/gonum/graph/path/control_flow.go
@@ -6,7 +6,7 @@ package path
 
 import (
 	"github.com/gonum/graph"
-	"github.com/gonum/graph/internal"
+	"github.com/gonum/graph/inteernal"
 )
 
 // PostDominatores returns all dominators for all nodes in g. It does not
diff --git a/Godeps/_workspace/src/github.com/gonum/graph/path/dijkstra_test.go b/Godeps/_workspace/src/github.com/gonum/graph/path/dijkstra_test.go
index c22d28f..0526ba9 100644
--- a/Godeps/_workspace/src/github.com/gonum/graph/path/dijkstra_test.go
+++ b/Godeps/_workspace/src/github.com/gonum/graph/path/dijkstra_test.go
@@ -11,7 +11,7 @@ import (
 	"testing"
 
 	"github.com/gonum/graph"
-	"github.com/gonum/graph/internal"
+	"github.com/gonum/graph/inteernal"
 	"github.com/gonum/graph/path"
 )
 
diff --git a/Godeps/_workspace/src/github.com/gonum/graph/path/floydwarshall_test.go b/Godeps/_workspace/src/github.com/gonum/graph/path/floydwarshall_test.go
index ea78e79..d23bb6a 100644
--- a/Godeps/_workspace/src/github.com/gonum/graph/path/floydwarshall_test.go
+++ b/Godeps/_workspace/src/github.com/gonum/graph/path/floydwarshall_test.go
@@ -11,7 +11,7 @@ import (
 	"testing"
 
 	"github.com/gonum/graph"
-	"github.com/gonum/graph/internal"
+	"github.com/gonum/graph/inteernal"
 	"github.com/gonum/graph/path"
 )
 
diff --git a/Godeps/_workspace/src/github.com/gonum/graph/path/johnson_apsp_test.go b/Godeps/_workspace/src/github.com/gonum/graph/path/johnson_apsp_test.go
index 814000f..588581d 100644
--- a/Godeps/_workspace/src/github.com/gonum/graph/path/johnson_apsp_test.go
+++ b/Godeps/_workspace/src/github.com/gonum/graph/path/johnson_apsp_test.go
@@ -11,7 +11,7 @@ import (
 	"testing"
 
 	"github.com/gonum/graph"
-	"github.com/gonum/graph/internal"
+	"github.com/gonum/graph/inteernal"
 	"github.com/gonum/graph/path"
 )
 
diff --git a/Godeps/_workspace/src/github.com/gonum/graph/path/spanning_tree.go b/Godeps/_workspace/src/github.com/gonum/graph/path/spanning_tree.go
index 99b30cb..2e3a501 100644
--- a/Godeps/_workspace/src/github.com/gonum/graph/path/spanning_tree.go
+++ b/Godeps/_workspace/src/github.com/gonum/graph/path/spanning_tree.go
@@ -9,7 +9,7 @@ import (
 
 	"github.com/gonum/graph"
 	"github.com/gonum/graph/concrete"
-	"github.com/gonum/graph/internal"
+	"github.com/gonum/graph/inteernal"
 )
 
 // EdgeListerGraph is an undirected graph than returns its complete set of edges.
diff --git a/Godeps/_workspace/src/github.com/gonum/graph/topo/bron_kerbosch.go b/Godeps/_workspace/src/github.com/gonum/graph/topo/bron_kerbosch.go
index 5e30d5b..a012b9b 100644
--- a/Godeps/_workspace/src/github.com/gonum/graph/topo/bron_kerbosch.go
+++ b/Godeps/_workspace/src/github.com/gonum/graph/topo/bron_kerbosch.go
@@ -6,7 +6,7 @@ package topo
 
 import (
 	"github.com/gonum/graph"
-	"github.com/gonum/graph/internal"
+	"github.com/gonum/graph/inteernal"
 )
 
 // VertexOrdering returns the vertex ordering and the k-cores of
diff --git a/Godeps/_workspace/src/github.com/gonum/graph/topo/bron_kerbosch_test.go b/Godeps/_workspace/src/github.com/gonum/graph/topo/bron_kerbosch_test.go
index 3d22c36..73e303c 100644
--- a/Godeps/_workspace/src/github.com/gonum/graph/topo/bron_kerbosch_test.go
+++ b/Godeps/_workspace/src/github.com/gonum/graph/topo/bron_kerbosch_test.go
@@ -10,7 +10,7 @@ import (
 	"testing"
 
 	"github.com/gonum/graph/concrete"
-	"github.com/gonum/graph/internal"
+	"github.com/gonum/graph/inteernal"
 	"github.com/gonum/graph/topo"
 )
 
diff --git a/Godeps/_workspace/src/github.com/gonum/graph/topo/johnson_cycles.go b/Godeps/_workspace/src/github.com/gonum/graph/topo/johnson_cycles.go
index 36d4cbd..ce9318e 100644
--- a/Godeps/_workspace/src/github.com/gonum/graph/topo/johnson_cycles.go
+++ b/Godeps/_workspace/src/github.com/gonum/graph/topo/johnson_cycles.go
@@ -8,7 +8,7 @@ import (
 	"sort"
 
 	"github.com/gonum/graph"
-	"github.com/gonum/graph/internal"
+	"github.com/gonum/graph/inteernal"
 )
 
 // johnson implements Johnson's "Finding all the elementary
diff --git a/Godeps/_workspace/src/github.com/gonum/graph/topo/johnson_cycles_test.go b/Godeps/_workspace/src/github.com/gonum/graph/topo/johnson_cycles_test.go
index a1ee6e1..149fff2 100644
--- a/Godeps/_workspace/src/github.com/gonum/graph/topo/johnson_cycles_test.go
+++ b/Godeps/_workspace/src/github.com/gonum/graph/topo/johnson_cycles_test.go
@@ -10,7 +10,7 @@ import (
 	"testing"
 
 	"github.com/gonum/graph/concrete"
-	"github.com/gonum/graph/internal"
+	"github.com/gonum/graph/inteernal"
 	"github.com/gonum/graph/topo"
 )
 
diff --git a/Godeps/_workspace/src/github.com/gonum/graph/topo/tarjan.go b/Godeps/_workspace/src/github.com/gonum/graph/topo/tarjan.go
index 908358c..f779bbb 100644
--- a/Godeps/_workspace/src/github.com/gonum/graph/topo/tarjan.go
+++ b/Godeps/_workspace/src/github.com/gonum/graph/topo/tarjan.go
@@ -9,7 +9,7 @@ import (
 	"sort"
 
 	"github.com/gonum/graph"
-	"github.com/gonum/graph/internal"
+	"github.com/gonum/graph/inteernal"
 )
 
 // Unorderable is an error containing sets of unorderable graph.Nodes.
diff --git a/Godeps/_workspace/src/github.com/gonum/graph/topo/tarjan_test.go b/Godeps/_workspace/src/github.com/gonum/graph/topo/tarjan_test.go
index 504633f..63c1a82 100644
--- a/Godeps/_workspace/src/github.com/gonum/graph/topo/tarjan_test.go
+++ b/Godeps/_workspace/src/github.com/gonum/graph/topo/tarjan_test.go
@@ -10,7 +10,7 @@ import (
 	"testing"
 
 	"github.com/gonum/graph/concrete"
-	"github.com/gonum/graph/internal"
+	"github.com/gonum/graph/inteernal"
 	"github.com/gonum/graph/topo"
 )
 
diff --git a/Godeps/_workspace/src/github.com/gonum/graph/topo/topo_test.go b/Godeps/_workspace/src/github.com/gonum/graph/topo/topo_test.go
index d903ee1..d71b788 100644
--- a/Godeps/_workspace/src/github.com/gonum/graph/topo/topo_test.go
+++ b/Godeps/_workspace/src/github.com/gonum/graph/topo/topo_test.go
@@ -11,7 +11,7 @@ import (
 
 	"github.com/gonum/graph"
 	"github.com/gonum/graph/concrete"
-	"github.com/gonum/graph/internal"
+	"github.com/gonum/graph/inteernal"
 	"github.com/gonum/graph/topo"
 )
 
diff --git a/Godeps/_workspace/src/github.com/gonum/graph/traverse/traverse.go b/Godeps/_workspace/src/github.com/gonum/graph/traverse/traverse.go
index bb0fdad..a7eb54d 100644
--- a/Godeps/_workspace/src/github.com/gonum/graph/traverse/traverse.go
+++ b/Godeps/_workspace/src/github.com/gonum/graph/traverse/traverse.go
@@ -7,7 +7,7 @@ package traverse
 
 import (
 	"github.com/gonum/graph"
-	"github.com/gonum/graph/internal"
+	"github.com/gonum/graph/inteernal"
 )
 
 // BreadthFirst implements stateful breadth-first graph traversal.
diff --git a/Godeps/_workspace/src/github.com/gonum/graph/traverse/traverse_test.go b/Godeps/_workspace/src/github.com/gonum/graph/traverse/traverse_test.go
index c5a4e2a..b771b46 100644
--- a/Godeps/_workspace/src/github.com/gonum/graph/traverse/traverse_test.go
+++ b/Godeps/_workspace/src/github.com/gonum/graph/traverse/traverse_test.go
@@ -12,7 +12,7 @@ import (
 
 	"github.com/gonum/graph"
 	"github.com/gonum/graph/concrete"
-	"github.com/gonum/graph/internal"
+	"github.com/gonum/graph/inteernal"
 	"github.com/gonum/graph/traverse"
 )
 
diff --git a/Godeps/_workspace/src/github.com/gonum/inteernal/asm/caxpy.go b/Godeps/_workspace/src/github.com/gonum/inteernal/asm/caxpy.go
new file mode 100644
index 0000000..80d802a
--- /dev/null
+++ b/Godeps/_workspace/src/github.com/gonum/inteernal/asm/caxpy.go
@@ -0,0 +1,22 @@
+// Generated code do not edit. Run `go generate`.
+
+// Copyright ©2015 The gonum Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+package asm
+
+// The extra z parameter is needed because of floats.AddScaledTo
+func CaxpyUnitary(alpha complex64, x, y, z []complex64) {
+	for i, v := range x {
+		z[i] = alpha*v + y[i]
+	}
+}
+
+func CaxpyInc(alpha complex64, x, y []complex64, n, incX, incY, ix, iy uintptr) {
+	for i := 0; i < int(n); i++ {
+		y[iy] += alpha * x[ix]
+		ix += incX
+		iy += incY
+	}
+}
diff --git a/Godeps/_workspace/src/github.com/gonum/inteernal/asm/cdotc.go b/Godeps/_workspace/src/github.com/gonum/inteernal/asm/cdotc.go
new file mode 100644
index 0000000..ed999e5
--- /dev/null
+++ b/Godeps/_workspace/src/github.com/gonum/inteernal/asm/cdotc.go
@@ -0,0 +1,23 @@
+// Generated code do not edit. Run `go generate`.
+
+// Copyright ©2015 The gonum Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+package asm
+
+func CdotcUnitary(x, y []complex64) (sum complex64) {
+	for i, v := range x {
+		sum += y[i] * conj(v)
+	}
+	return
+}
+
+func CdotcInc(x, y []complex64, n, incX, incY, ix, iy uintptr) (sum complex64) {
+	for i := 0; i < int(n); i++ {
+		sum += y[iy] * conj(x[ix])
+		ix += incX
+		iy += incY
+	}
+	return
+}
diff --git a/Godeps/_workspace/src/github.com/gonum/inteernal/asm/cdotu.go b/Godeps/_workspace/src/github.com/gonum/inteernal/asm/cdotu.go
new file mode 100644
index 0000000..3392ee2
--- /dev/null
+++ b/Godeps/_workspace/src/github.com/gonum/inteernal/asm/cdotu.go
@@ -0,0 +1,23 @@
+// Generated code do not edit. Run `go generate`.
+
+// Copyright ©2015 The gonum Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+package asm
+
+func CdotuUnitary(x, y []complex64) (sum complex64) {
+	for i, v := range x {
+		sum += y[i] * v
+	}
+	return
+}
+
+func CdotuInc(x, y []complex64, n, incX, incY, ix, iy uintptr) (sum complex64) {
+	for i := 0; i < int(n); i++ {
+		sum += y[iy] * x[ix]
+		ix += incX
+		iy += incY
+	}
+	return
+}
diff --git a/Godeps/_workspace/src/github.com/gonum/inteernal/asm/complex b/Godeps/_workspace/src/github.com/gonum/inteernal/asm/complex
new file mode 100644
index 0000000..b26e4e6
--- /dev/null
+++ b/Godeps/_workspace/src/github.com/gonum/inteernal/asm/complex
@@ -0,0 +1,58 @@
+#!/usr/bin/env bash
+
+# Copyright ©2015 The gonum Authors. All rights reserved.
+# Use of this source code is governed by a BSD-style
+# license that can be found in the LICENSE file.
+
+echo Generating zdotu.go
+echo -e '// Generated code do not edit. Run `go generate`.\n' > zdotu.go
+cat ddot.go \
+| grep -v '//+build' \
+| gofmt -r 'float64 -> complex128' \
+| sed 's/Ddot/Zdotu/' \
+>> zdotu.go
+
+echo Generating zdotc.go
+echo -e '// Generated code do not edit. Run `go generate`.\n' > zdotc.go
+cat ddot.go \
+| grep -v '//+build' \
+| gofmt -r 'float64 -> complex128' \
+| gofmt -r 'y[i] * v -> y[i] * cmplx.Conj(v)' \
+| sed 's/Ddot/Zdotc/' \
+| goimports \
+>> zdotc.go
+
+echo Generating zaxpy.go
+echo -e '// Generated code do not edit. Run `go generate`.\n' > zaxpy.go
+cat daxpy.go \
+| grep -v '//+build' \
+| gofmt -r 'float64 -> complex128' \
+| sed 's/Daxpy/Zaxpy/' \
+>> zaxpy.go
+
+echo Generating cdotu.go
+echo -e '// Generated code do not edit. Run `go generate`.\n' > cdotu.go
+cat ddot.go \
+| grep -v '//+build' \
+| gofmt -r 'float64 -> complex64' \
+| sed 's/Ddot/Cdotu/' \
+>> cdotu.go
+
+echo Generating cdotc.go
+echo -e '// Generated code do not edit. Run `go generate`.\n' > cdotc.go
+cat ddot.go \
+| grep -v '//+build' \
+| gofmt -r 'float64 -> complex64' \
+| gofmt -r 'y[i] * v -> y[i] * conj(v)' \
+| sed 's/Ddot/Cdotc/' \
+| goimports \
+>> cdotc.go
+
+echo Generating caxpy.go
+echo -e '// Generated code do not edit. Run `go generate`.\n' > caxpy.go
+cat daxpy.go \
+| grep -v '//+build' \
+| gofmt -r 'float64 -> complex64' \
+| sed 's/Daxpy/Caxpy/' \
+>> caxpy.go
+
diff --git a/Godeps/_workspace/src/github.com/gonum/inteernal/asm/conj.go b/Godeps/_workspace/src/github.com/gonum/inteernal/asm/conj.go
new file mode 100644
index 0000000..1cadb2a
--- /dev/null
+++ b/Godeps/_workspace/src/github.com/gonum/inteernal/asm/conj.go
@@ -0,0 +1,7 @@
+// Copyright ©2015 The gonum Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+package asm
+
+func conj(c complex64) complex64 { return complex(real(c), -imag(c)) }
diff --git a/Godeps/_workspace/src/github.com/gonum/inteernal/asm/daxpy.go b/Godeps/_workspace/src/github.com/gonum/inteernal/asm/daxpy.go
new file mode 100644
index 0000000..24979fc
--- /dev/null
+++ b/Godeps/_workspace/src/github.com/gonum/inteernal/asm/daxpy.go
@@ -0,0 +1,22 @@
+// Copyright ©2015 The gonum Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+//+build !amd64 noasm
+
+package asm
+
+// The extra z parameter is needed because of floats.AddScaledTo
+func DaxpyUnitary(alpha float64, x, y, z []float64) {
+	for i, v := range x {
+		z[i] = alpha*v + y[i]
+	}
+}
+
+func DaxpyInc(alpha float64, x, y []float64, n, incX, incY, ix, iy uintptr) {
+	for i := 0; i < int(n); i++ {
+		y[iy] += alpha * x[ix]
+		ix += incX
+		iy += incY
+	}
+}
diff --git a/Godeps/_workspace/src/github.com/gonum/inteernal/asm/daxpy_amd64.go b/Godeps/_workspace/src/github.com/gonum/inteernal/asm/daxpy_amd64.go
new file mode 100644
index 0000000..d1aeacf
--- /dev/null
+++ b/Godeps/_workspace/src/github.com/gonum/inteernal/asm/daxpy_amd64.go
@@ -0,0 +1,12 @@
+// Copyright ©2015 The gonum Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+//+build !noasm
+
+package asm
+
+// The extra z parameter is needed because of floats.AddScaledTo
+func DaxpyUnitary(alpha float64, x, y, z []float64)
+
+func DaxpyInc(alpha float64, x, y []float64, n, incX, incY, ix, iy uintptr)
diff --git a/Godeps/_workspace/src/github.com/gonum/inteernal/asm/daxpy_amd64.s b/Godeps/_workspace/src/github.com/gonum/inteernal/asm/daxpy_amd64.s
new file mode 100644
index 0000000..18f2d3c
--- /dev/null
+++ b/Godeps/_workspace/src/github.com/gonum/inteernal/asm/daxpy_amd64.s
@@ -0,0 +1,140 @@
+// Copyright ©2015 The gonum Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+//
+// Some of the loop unrolling code is copied from:
+// http://golang.org/src/math/big/arith_amd64.s
+// which is distributed under these terms:
+//
+// Copyright (c) 2012 The Go Authors. All rights reserved.
+// 
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions are
+// met:
+// 
+//    * Redistributions of source code must retain the above copyright
+// notice, this list of conditions and the following disclaimer.
+//    * Redistributions in binary form must reproduce the above
+// copyright notice, this list of conditions and the following disclaimer
+// in the documentation and/or other materials provided with the
+// distribution.
+//    * Neither the name of Google Inc. nor the names of its
+// contributors may be used to endorse or promote products derived from
+// this software without specific prior written permission.
+// 
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+//+build !noasm
+
+// TODO(fhs): use textflag.h after we drop Go 1.3 support
+//#include "textflag.h"
+// Don't insert stack check preamble.
+#define NOSPLIT	4
+
+
+// func DaxpyUnitary(alpha float64, x, y, z []float64)
+// This function assumes len(y) >= len(x).
+TEXT ·DaxpyUnitary(SB),NOSPLIT,$0
+	MOVHPD alpha+0(FP), X7
+	MOVLPD alpha+0(FP), X7
+	MOVQ x_len+16(FP), DI	// n = len(x)
+	MOVQ x+8(FP), R8
+	MOVQ y+32(FP), R9
+	MOVQ z+56(FP), R10
+	
+	MOVQ $0, SI				// i = 0
+	SUBQ $2, DI				// n -= 2
+	JL V1					// if n < 0 goto V1
+
+U1:	// n >= 0
+	// y[i] += alpha * x[i] unrolled 2x.
+	MOVUPD 0(R8)(SI*8), X0
+	MOVUPD 0(R9)(SI*8), X1
+	MULPD X7, X0
+	ADDPD X0, X1
+	MOVUPD X1, 0(R10)(SI*8)
+	
+	ADDQ $2, SI				// i += 2
+	SUBQ $2, DI				// n -= 2
+	JGE U1					// if n >= 0 goto U1
+
+V1:
+	ADDQ $2, DI				// n += 2
+	JLE E1					// if n <= 0 goto E1
+	
+	// y[i] += alpha * x[i] for last iteration if n is odd.
+	MOVSD 0(R8)(SI*8), X0
+	MOVSD 0(R9)(SI*8), X1
+	MULSD X7, X0
+	ADDSD X0, X1
+	MOVSD X1, 0(R10)(SI*8)
+
+E1:
+	RET
+
+
+// func DaxpyInc(alpha float64, x, y []float64, n, incX, incY, ix, iy uintptr)
+TEXT ·DaxpyInc(SB),NOSPLIT,$0
+	MOVHPD alpha+0(FP), X7
+	MOVLPD alpha+0(FP), X7
+	MOVQ x+8(FP), R8
+	MOVQ y+32(FP), R9
+	MOVQ n+56(FP), CX
+	MOVQ incX+64(FP), R11
+	MOVQ incY+72(FP), R12
+	MOVQ ix+80(FP), SI
+	MOVQ iy+88(FP), DI
+
+	MOVQ SI, AX				// nextX = ix
+	MOVQ DI, BX				// nextY = iy
+	ADDQ R11, AX			// nextX += incX
+	ADDQ R12, BX			// nextY += incX
+	SHLQ $1, R11			// indX *= 2
+	SHLQ $1, R12			// indY *= 2
+	
+	SUBQ $2, CX				// n -= 2
+	JL V2					// if n < 0 goto V2
+
+U2:	// n >= 0
+	// y[i] += alpha * x[i] unrolled 2x.
+	MOVHPD 0(R8)(SI*8), X0
+	MOVHPD 0(R9)(DI*8), X1
+	MOVLPD 0(R8)(AX*8), X0
+	MOVLPD 0(R9)(BX*8), X1
+	
+	MULPD X7, X0
+	ADDPD X0, X1
+	MOVHPD X1, 0(R9)(DI*8)
+	MOVLPD X1, 0(R9)(BX*8)
+
+	ADDQ R11, SI			// ix += incX
+	ADDQ R12, DI			// iy += incY
+	ADDQ R11, AX			// nextX += incX
+	ADDQ R12, BX			// nextY += incY
+
+	SUBQ $2, CX				// n -= 2
+	JGE U2					// if n >= 0 goto U2
+
+V2:
+	ADDQ $2, CX				// n += 2
+	JLE E2					// if n <= 0 goto E2
+	
+	// y[i] += alpha * x[i] for the last iteration if n is odd.
+	MOVSD 0(R8)(SI*8), X0
+	MOVSD 0(R9)(DI*8), X1
+	MULSD X7, X0
+	ADDSD X0, X1
+	MOVSD X1, 0(R9)(DI*8)
+
+E2:
+	RET
diff --git a/Godeps/_workspace/src/github.com/gonum/inteernal/asm/ddot.go b/Godeps/_workspace/src/github.com/gonum/inteernal/asm/ddot.go
new file mode 100644
index 0000000..7e69957
--- /dev/null
+++ b/Godeps/_workspace/src/github.com/gonum/inteernal/asm/ddot.go
@@ -0,0 +1,23 @@
+// Copyright ©2015 The gonum Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+//+build !amd64 noasm
+
+package asm
+
+func DdotUnitary(x, y []float64) (sum float64) {
+	for i, v := range x {
+		sum += y[i] * v
+	}
+	return
+}
+
+func DdotInc(x, y []float64, n, incX, incY, ix, iy uintptr) (sum float64) {
+	for i := 0; i < int(n); i++ {
+		sum += y[iy] * x[ix]
+		ix += incX
+		iy += incY
+	}
+	return
+}
diff --git a/Godeps/_workspace/src/github.com/gonum/inteernal/asm/ddot_amd64.go b/Godeps/_workspace/src/github.com/gonum/inteernal/asm/ddot_amd64.go
new file mode 100644
index 0000000..7fa634a
--- /dev/null
+++ b/Godeps/_workspace/src/github.com/gonum/inteernal/asm/ddot_amd64.go
@@ -0,0 +1,10 @@
+// Copyright ©2015 The gonum Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+//+build !noasm
+
+package asm
+
+func DdotUnitary(x, y []float64) (sum float64)
+func DdotInc(x, y []float64, n, incX, incY, ix, iy uintptr) (sum float64)
diff --git a/Godeps/_workspace/src/github.com/gonum/inteernal/asm/ddot_amd64.s b/Godeps/_workspace/src/github.com/gonum/inteernal/asm/ddot_amd64.s
new file mode 100644
index 0000000..a898bbb
--- /dev/null
+++ b/Godeps/_workspace/src/github.com/gonum/inteernal/asm/ddot_amd64.s
@@ -0,0 +1,140 @@
+// Copyright ©2015 The gonum Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+//
+// Some of the loop unrolling code is copied from:
+// http://golang.org/src/math/big/arith_amd64.s
+// which is distributed under these terms:
+//
+// Copyright (c) 2012 The Go Authors. All rights reserved.
+// 
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions are
+// met:
+// 
+//    * Redistributions of source code must retain the above copyright
+// notice, this list of conditions and the following disclaimer.
+//    * Redistributions in binary form must reproduce the above
+// copyright notice, this list of conditions and the following disclaimer
+// in the documentation and/or other materials provided with the
+// distribution.
+//    * Neither the name of Google Inc. nor the names of its
+// contributors may be used to endorse or promote products derived from
+// this software without specific prior written permission.
+// 
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+//+build !noasm
+
+// TODO(fhs): use textflag.h after we drop Go 1.3 support
+//#include "textflag.h"
+// Don't insert stack check preamble.
+#define NOSPLIT	4
+
+
+// func DdotUnitary(x, y []float64) (sum float64)
+// This function assumes len(y) >= len(x).
+TEXT ·DdotUnitary(SB),NOSPLIT,$0
+	MOVQ x_len+8(FP), DI	// n = len(x)
+	MOVQ x+0(FP), R8
+	MOVQ y+24(FP), R9
+	
+	MOVQ $0, SI				// i = 0
+	MOVSD $(0.0), X7		// sum = 0
+	
+	SUBQ $2, DI				// n -= 2
+	JL V1					// if n < 0 goto V1
+
+U1:	// n >= 0
+	// sum += x[i] * y[i] unrolled 2x.
+	MOVUPD 0(R8)(SI*8), X0
+	MOVUPD 0(R9)(SI*8), X1
+	MULPD X1, X0
+	ADDPD X0, X7
+	
+	ADDQ $2, SI				// i += 2
+	SUBQ $2, DI				// n -= 2
+	JGE U1					// if n >= 0 goto U1
+
+V1:	// n > 0
+	ADDQ $2, DI				// n += 2
+	JLE E1					// if n <= 0 goto E1
+	
+	// sum += x[i] * y[i] for last iteration if n is odd.
+	MOVSD 0(R8)(SI*8), X0
+	MOVSD 0(R9)(SI*8), X1
+	MULSD X1, X0
+	ADDSD X0, X7
+
+E1:
+	// Add the two sums together.
+	MOVSD X7, X0
+	UNPCKHPD X7, X7
+	ADDSD X0, X7
+	MOVSD X7, sum+48(FP)	// return final sum
+	RET
+
+
+// func DdotInc(x, y []float64, n, incX, incY, ix, iy uintptr) (sum float64)
+TEXT ·DdotInc(SB),NOSPLIT,$0
+	MOVQ x+0(FP), R8
+	MOVQ y+24(FP), R9
+	MOVQ n+48(FP), CX
+	MOVQ incX+56(FP), R11
+	MOVQ incY+64(FP), R12
+	MOVQ ix+72(FP), R13
+	MOVQ iy+80(FP), R14
+	
+	MOVSD $(0.0), X7		// sum = 0
+	LEAQ (R8)(R13*8), SI	// p = &x[ix]
+	LEAQ (R9)(R14*8), DI	// q = &y[ix]
+	SHLQ $3, R11			// incX *= sizeof(float64)
+	SHLQ $3, R12			// indY *= sizeof(float64)
+	
+	SUBQ $2, CX				// n -= 2
+	JL V2					// if n < 0 goto V2
+
+U2:	// n >= 0
+	// sum += *p * *q unrolled 2x.
+	MOVHPD (SI), X0
+	MOVHPD (DI), X1
+	ADDQ R11, SI			// p += incX
+	ADDQ R12, DI			// q += incY
+	MOVLPD (SI), X0
+	MOVLPD (DI), X1
+	ADDQ R11, SI			// p += incX
+	ADDQ R12, DI			// q += incY
+	
+	MULPD X1, X0
+	ADDPD X0, X7
+
+	SUBQ $2, CX				// n -= 2
+	JGE U2					// if n >= 0 goto U2
+
+V2:
+	ADDQ $2, CX				// n += 2
+	JLE E2					// if n <= 0 goto E2
+	
+	// sum += *p * *q for the last iteration if n is odd.
+	MOVSD (SI), X0
+	MULSD (DI), X0
+	ADDSD X0, X7
+
+E2:
+	// Add the two sums together.
+	MOVSD X7, X0
+	UNPCKHPD X7, X7
+	ADDSD X0, X7
+	MOVSD X7, sum+88(FP)	// return final sum
+	RET
+  
\ No newline at end of file
diff --git a/Godeps/_workspace/src/github.com/gonum/inteernal/asm/dsdot.go b/Godeps/_workspace/src/github.com/gonum/inteernal/asm/dsdot.go
new file mode 100644
index 0000000..8450689
--- /dev/null
+++ b/Godeps/_workspace/src/github.com/gonum/inteernal/asm/dsdot.go
@@ -0,0 +1,23 @@
+// Generated code do not edit. Run `go generate`.
+
+// Copyright ©2015 The gonum Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+package asm
+
+func DsdotUnitary(x, y []float32) (sum float64) {
+	for i, v := range x {
+		sum += float64(y[i]) * float64(v)
+	}
+	return
+}
+
+func DsdotInc(x, y []float32, n, incX, incY, ix, iy uintptr) (sum float64) {
+	for i := 0; i < int(n); i++ {
+		sum += float64(y[iy]) * float64(x[ix])
+		ix += incX
+		iy += incY
+	}
+	return
+}
diff --git a/Godeps/_workspace/src/github.com/gonum/inteernal/asm/generate.go b/Godeps/_workspace/src/github.com/gonum/inteernal/asm/generate.go
new file mode 100644
index 0000000..e252140
--- /dev/null
+++ b/Godeps/_workspace/src/github.com/gonum/inteernal/asm/generate.go
@@ -0,0 +1,8 @@
+// Copyright ©2015 The gonum Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+//go:generate ./single_precision
+//go:generate ./complex
+
+package asm
diff --git a/Godeps/_workspace/src/github.com/gonum/inteernal/asm/saxpy.go b/Godeps/_workspace/src/github.com/gonum/inteernal/asm/saxpy.go
new file mode 100644
index 0000000..3ef767f
--- /dev/null
+++ b/Godeps/_workspace/src/github.com/gonum/inteernal/asm/saxpy.go
@@ -0,0 +1,22 @@
+// Generated code do not edit. Run `go generate`.
+
+// Copyright ©2015 The gonum Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+package asm
+
+// The extra z parameter is needed because of floats.AddScaledTo
+func SaxpyUnitary(alpha float32, x, y, z []float32) {
+	for i, v := range x {
+		z[i] = alpha*v + y[i]
+	}
+}
+
+func SaxpyInc(alpha float32, x, y []float32, n, incX, incY, ix, iy uintptr) {
+	for i := 0; i < int(n); i++ {
+		y[iy] += alpha * x[ix]
+		ix += incX
+		iy += incY
+	}
+}
diff --git a/Godeps/_workspace/src/github.com/gonum/inteernal/asm/sdot.go b/Godeps/_workspace/src/github.com/gonum/inteernal/asm/sdot.go
new file mode 100644
index 0000000..0cef5de
--- /dev/null
+++ b/Godeps/_workspace/src/github.com/gonum/inteernal/asm/sdot.go
@@ -0,0 +1,23 @@
+// Generated code do not edit. Run `go generate`.
+
+// Copyright ©2015 The gonum Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+package asm
+
+func SdotUnitary(x, y []float32) (sum float32) {
+	for i, v := range x {
+		sum += y[i] * v
+	}
+	return
+}
+
+func SdotInc(x, y []float32, n, incX, incY, ix, iy uintptr) (sum float32) {
+	for i := 0; i < int(n); i++ {
+		sum += y[iy] * x[ix]
+		ix += incX
+		iy += incY
+	}
+	return
+}
diff --git a/Godeps/_workspace/src/github.com/gonum/inteernal/asm/single_precision b/Godeps/_workspace/src/github.com/gonum/inteernal/asm/single_precision
new file mode 100644
index 0000000..a937a97
--- /dev/null
+++ b/Godeps/_workspace/src/github.com/gonum/inteernal/asm/single_precision
@@ -0,0 +1,30 @@
+#!/usr/bin/env bash
+
+# Copyright ©2015 The gonum Authors. All rights reserved.
+# Use of this source code is governed by a BSD-style
+# license that can be found in the LICENSE file.
+
+echo Generating dsdot.go
+echo -e '// Generated code do not edit. Run `go generate`.\n' > dsdot.go
+cat ddot.go \
+| grep -v '//+build' \
+| gofmt -r '[]float64 -> []float32' \
+| gofmt -r 'a * b -> float64(a) * float64(b)' \
+| sed 's/Ddot/Dsdot/' \
+>> dsdot.go
+
+echo Generating sdot.go
+echo -e '// Generated code do not edit. Run `go generate`.\n' > sdot.go
+cat ddot.go \
+| grep -v '//+build' \
+| gofmt -r 'float64 -> float32' \
+| sed 's/Ddot/Sdot/' \
+>> sdot.go
+
+echo Generating saxpy.go
+echo -e '// Generated code do not edit. Run `go generate`.\n' > saxpy.go
+cat daxpy.go \
+| grep -v '//+build' \
+| gofmt -r 'float64 -> float32' \
+| sed 's/Daxpy/Saxpy/' \
+>> saxpy.go
diff --git a/Godeps/_workspace/src/github.com/gonum/inteernal/asm/zaxpy.go b/Godeps/_workspace/src/github.com/gonum/inteernal/asm/zaxpy.go
new file mode 100644
index 0000000..9478f25
--- /dev/null
+++ b/Godeps/_workspace/src/github.com/gonum/inteernal/asm/zaxpy.go
@@ -0,0 +1,22 @@
+// Generated code do not edit. Run `go generate`.
+
+// Copyright ©2015 The gonum Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+package asm
+
+// The extra z parameter is needed because of floats.AddScaledTo
+func ZaxpyUnitary(alpha complex128, x, y, z []complex128) {
+	for i, v := range x {
+		z[i] = alpha*v + y[i]
+	}
+}
+
+func ZaxpyInc(alpha complex128, x, y []complex128, n, incX, incY, ix, iy uintptr) {
+	for i := 0; i < int(n); i++ {
+		y[iy] += alpha * x[ix]
+		ix += incX
+		iy += incY
+	}
+}
diff --git a/Godeps/_workspace/src/github.com/gonum/inteernal/asm/zdotc.go b/Godeps/_workspace/src/github.com/gonum/inteernal/asm/zdotc.go
new file mode 100644
index 0000000..7b8febc
--- /dev/null
+++ b/Godeps/_workspace/src/github.com/gonum/inteernal/asm/zdotc.go
@@ -0,0 +1,25 @@
+// Generated code do not edit. Run `go generate`.
+
+// Copyright ©2015 The gonum Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+package asm
+
+import "math/cmplx"
+
+func ZdotcUnitary(x, y []complex128) (sum complex128) {
+	for i, v := range x {
+		sum += y[i] * cmplx.Conj(v)
+	}
+	return
+}
+
+func ZdotcInc(x, y []complex128, n, incX, incY, ix, iy uintptr) (sum complex128) {
+	for i := 0; i < int(n); i++ {
+		sum += y[iy] * cmplx.Conj(x[ix])
+		ix += incX
+		iy += incY
+	}
+	return
+}
diff --git a/Godeps/_workspace/src/github.com/gonum/inteernal/asm/zdotu.go b/Godeps/_workspace/src/github.com/gonum/inteernal/asm/zdotu.go
new file mode 100644
index 0000000..82c1fe2
--- /dev/null
+++ b/Godeps/_workspace/src/github.com/gonum/inteernal/asm/zdotu.go
@@ -0,0 +1,23 @@
+// Generated code do not edit. Run `go generate`.
+
+// Copyright ©2015 The gonum Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+package asm
+
+func ZdotuUnitary(x, y []complex128) (sum complex128) {
+	for i, v := range x {
+		sum += y[i] * v
+	}
+	return
+}
+
+func ZdotuInc(x, y []complex128, n, incX, incY, ix, iy uintptr) (sum complex128) {
+	for i := 0; i < int(n); i++ {
+		sum += y[iy] * x[ix]
+		ix += incX
+		iy += incY
+	}
+	return
+}
diff --git a/Godeps/_workspace/src/github.com/gonum/internal/asm/caxpy.go b/Godeps/_workspace/src/github.com/gonum/internal/asm/caxpy.go
deleted file mode 100644
index 80d802a..0000000
--- a/Godeps/_workspace/src/github.com/gonum/internal/asm/caxpy.go
+++ /dev/null
@@ -1,22 +0,0 @@
-// Generated code do not edit. Run `go generate`.
-
-// Copyright ©2015 The gonum Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style
-// license that can be found in the LICENSE file.
-
-package asm
-
-// The extra z parameter is needed because of floats.AddScaledTo
-func CaxpyUnitary(alpha complex64, x, y, z []complex64) {
-	for i, v := range x {
-		z[i] = alpha*v + y[i]
-	}
-}
-
-func CaxpyInc(alpha complex64, x, y []complex64, n, incX, incY, ix, iy uintptr) {
-	for i := 0; i < int(n); i++ {
-		y[iy] += alpha * x[ix]
-		ix += incX
-		iy += incY
-	}
-}
diff --git a/Godeps/_workspace/src/github.com/gonum/internal/asm/cdotc.go b/Godeps/_workspace/src/github.com/gonum/internal/asm/cdotc.go
deleted file mode 100644
index ed999e5..0000000
--- a/Godeps/_workspace/src/github.com/gonum/internal/asm/cdotc.go
+++ /dev/null
@@ -1,23 +0,0 @@
-// Generated code do not edit. Run `go generate`.
-
-// Copyright ©2015 The gonum Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style
-// license that can be found in the LICENSE file.
-
-package asm
-
-func CdotcUnitary(x, y []complex64) (sum complex64) {
-	for i, v := range x {
-		sum += y[i] * conj(v)
-	}
-	return
-}
-
-func CdotcInc(x, y []complex64, n, incX, incY, ix, iy uintptr) (sum complex64) {
-	for i := 0; i < int(n); i++ {
-		sum += y[iy] * conj(x[ix])
-		ix += incX
-		iy += incY
-	}
-	return
-}
diff --git a/Godeps/_workspace/src/github.com/gonum/internal/asm/cdotu.go b/Godeps/_workspace/src/github.com/gonum/internal/asm/cdotu.go
deleted file mode 100644
index 3392ee2..0000000
--- a/Godeps/_workspace/src/github.com/gonum/internal/asm/cdotu.go
+++ /dev/null
@@ -1,23 +0,0 @@
-// Generated code do not edit. Run `go generate`.
-
-// Copyright ©2015 The gonum Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style
-// license that can be found in the LICENSE file.
-
-package asm
-
-func CdotuUnitary(x, y []complex64) (sum complex64) {
-	for i, v := range x {
-		sum += y[i] * v
-	}
-	return
-}
-
-func CdotuInc(x, y []complex64, n, incX, incY, ix, iy uintptr) (sum complex64) {
-	for i := 0; i < int(n); i++ {
-		sum += y[iy] * x[ix]
-		ix += incX
-		iy += incY
-	}
-	return
-}
diff --git a/Godeps/_workspace/src/github.com/gonum/internal/asm/complex b/Godeps/_workspace/src/github.com/gonum/internal/asm/complex
deleted file mode 100644
index b26e4e6..0000000
--- a/Godeps/_workspace/src/github.com/gonum/internal/asm/complex
+++ /dev/null
@@ -1,58 +0,0 @@
-#!/usr/bin/env bash
-
-# Copyright ©2015 The gonum Authors. All rights reserved.
-# Use of this source code is governed by a BSD-style
-# license that can be found in the LICENSE file.
-
-echo Generating zdotu.go
-echo -e '// Generated code do not edit. Run `go generate`.\n' > zdotu.go
-cat ddot.go \
-| grep -v '//+build' \
-| gofmt -r 'float64 -> complex128' \
-| sed 's/Ddot/Zdotu/' \
->> zdotu.go
-
-echo Generating zdotc.go
-echo -e '// Generated code do not edit. Run `go generate`.\n' > zdotc.go
-cat ddot.go \
-| grep -v '//+build' \
-| gofmt -r 'float64 -> complex128' \
-| gofmt -r 'y[i] * v -> y[i] * cmplx.Conj(v)' \
-| sed 's/Ddot/Zdotc/' \
-| goimports \
->> zdotc.go
-
-echo Generating zaxpy.go
-echo -e '// Generated code do not edit. Run `go generate`.\n' > zaxpy.go
-cat daxpy.go \
-| grep -v '//+build' \
-| gofmt -r 'float64 -> complex128' \
-| sed 's/Daxpy/Zaxpy/' \
->> zaxpy.go
-
-echo Generating cdotu.go
-echo -e '// Generated code do not edit. Run `go generate`.\n' > cdotu.go
-cat ddot.go \
-| grep -v '//+build' \
-| gofmt -r 'float64 -> complex64' \
-| sed 's/Ddot/Cdotu/' \
->> cdotu.go
-
-echo Generating cdotc.go
-echo -e '// Generated code do not edit. Run `go generate`.\n' > cdotc.go
-cat ddot.go \
-| grep -v '//+build' \
-| gofmt -r 'float64 -> complex64' \
-| gofmt -r 'y[i] * v -> y[i] * conj(v)' \
-| sed 's/Ddot/Cdotc/' \
-| goimports \
->> cdotc.go
-
-echo Generating caxpy.go
-echo -e '// Generated code do not edit. Run `go generate`.\n' > caxpy.go
-cat daxpy.go \
-| grep -v '//+build' \
-| gofmt -r 'float64 -> complex64' \
-| sed 's/Daxpy/Caxpy/' \
->> caxpy.go
-
diff --git a/Godeps/_workspace/src/github.com/gonum/internal/asm/conj.go b/Godeps/_workspace/src/github.com/gonum/internal/asm/conj.go
deleted file mode 100644
index 1cadb2a..0000000
--- a/Godeps/_workspace/src/github.com/gonum/internal/asm/conj.go
+++ /dev/null
@@ -1,7 +0,0 @@
-// Copyright ©2015 The gonum Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style
-// license that can be found in the LICENSE file.
-
-package asm
-
-func conj(c complex64) complex64 { return complex(real(c), -imag(c)) }
diff --git a/Godeps/_workspace/src/github.com/gonum/internal/asm/daxpy.go b/Godeps/_workspace/src/github.com/gonum/internal/asm/daxpy.go
deleted file mode 100644
index 24979fc..0000000
--- a/Godeps/_workspace/src/github.com/gonum/internal/asm/daxpy.go
+++ /dev/null
@@ -1,22 +0,0 @@
-// Copyright ©2015 The gonum Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style
-// license that can be found in the LICENSE file.
-
-//+build !amd64 noasm
-
-package asm
-
-// The extra z parameter is needed because of floats.AddScaledTo
-func DaxpyUnitary(alpha float64, x, y, z []float64) {
-	for i, v := range x {
-		z[i] = alpha*v + y[i]
-	}
-}
-
-func DaxpyInc(alpha float64, x, y []float64, n, incX, incY, ix, iy uintptr) {
-	for i := 0; i < int(n); i++ {
-		y[iy] += alpha * x[ix]
-		ix += incX
-		iy += incY
-	}
-}
diff --git a/Godeps/_workspace/src/github.com/gonum/internal/asm/daxpy_amd64.go b/Godeps/_workspace/src/github.com/gonum/internal/asm/daxpy_amd64.go
deleted file mode 100644
index d1aeacf..0000000
--- a/Godeps/_workspace/src/github.com/gonum/internal/asm/daxpy_amd64.go
+++ /dev/null
@@ -1,12 +0,0 @@
-// Copyright ©2015 The gonum Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style
-// license that can be found in the LICENSE file.
-
-//+build !noasm
-
-package asm
-
-// The extra z parameter is needed because of floats.AddScaledTo
-func DaxpyUnitary(alpha float64, x, y, z []float64)
-
-func DaxpyInc(alpha float64, x, y []float64, n, incX, incY, ix, iy uintptr)
diff --git a/Godeps/_workspace/src/github.com/gonum/internal/asm/daxpy_amd64.s b/Godeps/_workspace/src/github.com/gonum/internal/asm/daxpy_amd64.s
deleted file mode 100644
index 18f2d3c..0000000
--- a/Godeps/_workspace/src/github.com/gonum/internal/asm/daxpy_amd64.s
+++ /dev/null
@@ -1,140 +0,0 @@
-// Copyright ©2015 The gonum Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style
-// license that can be found in the LICENSE file.
-//
-// Some of the loop unrolling code is copied from:
-// http://golang.org/src/math/big/arith_amd64.s
-// which is distributed under these terms:
-//
-// Copyright (c) 2012 The Go Authors. All rights reserved.
-// 
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions are
-// met:
-// 
-//    * Redistributions of source code must retain the above copyright
-// notice, this list of conditions and the following disclaimer.
-//    * Redistributions in binary form must reproduce the above
-// copyright notice, this list of conditions and the following disclaimer
-// in the documentation and/or other materials provided with the
-// distribution.
-//    * Neither the name of Google Inc. nor the names of its
-// contributors may be used to endorse or promote products derived from
-// this software without specific prior written permission.
-// 
-// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
-// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
-// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
-// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
-// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
-// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
-// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
-// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
-// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-//+build !noasm
-
-// TODO(fhs): use textflag.h after we drop Go 1.3 support
-//#include "textflag.h"
-// Don't insert stack check preamble.
-#define NOSPLIT	4
-
-
-// func DaxpyUnitary(alpha float64, x, y, z []float64)
-// This function assumes len(y) >= len(x).
-TEXT ·DaxpyUnitary(SB),NOSPLIT,$0
-	MOVHPD alpha+0(FP), X7
-	MOVLPD alpha+0(FP), X7
-	MOVQ x_len+16(FP), DI	// n = len(x)
-	MOVQ x+8(FP), R8
-	MOVQ y+32(FP), R9
-	MOVQ z+56(FP), R10
-	
-	MOVQ $0, SI				// i = 0
-	SUBQ $2, DI				// n -= 2
-	JL V1					// if n < 0 goto V1
-
-U1:	// n >= 0
-	// y[i] += alpha * x[i] unrolled 2x.
-	MOVUPD 0(R8)(SI*8), X0
-	MOVUPD 0(R9)(SI*8), X1
-	MULPD X7, X0
-	ADDPD X0, X1
-	MOVUPD X1, 0(R10)(SI*8)
-	
-	ADDQ $2, SI				// i += 2
-	SUBQ $2, DI				// n -= 2
-	JGE U1					// if n >= 0 goto U1
-
-V1:
-	ADDQ $2, DI				// n += 2
-	JLE E1					// if n <= 0 goto E1
-	
-	// y[i] += alpha * x[i] for last iteration if n is odd.
-	MOVSD 0(R8)(SI*8), X0
-	MOVSD 0(R9)(SI*8), X1
-	MULSD X7, X0
-	ADDSD X0, X1
-	MOVSD X1, 0(R10)(SI*8)
-
-E1:
-	RET
-
-
-// func DaxpyInc(alpha float64, x, y []float64, n, incX, incY, ix, iy uintptr)
-TEXT ·DaxpyInc(SB),NOSPLIT,$0
-	MOVHPD alpha+0(FP), X7
-	MOVLPD alpha+0(FP), X7
-	MOVQ x+8(FP), R8
-	MOVQ y+32(FP), R9
-	MOVQ n+56(FP), CX
-	MOVQ incX+64(FP), R11
-	MOVQ incY+72(FP), R12
-	MOVQ ix+80(FP), SI
-	MOVQ iy+88(FP), DI
-
-	MOVQ SI, AX				// nextX = ix
-	MOVQ DI, BX				// nextY = iy
-	ADDQ R11, AX			// nextX += incX
-	ADDQ R12, BX			// nextY += incX
-	SHLQ $1, R11			// indX *= 2
-	SHLQ $1, R12			// indY *= 2
-	
-	SUBQ $2, CX				// n -= 2
-	JL V2					// if n < 0 goto V2
-
-U2:	// n >= 0
-	// y[i] += alpha * x[i] unrolled 2x.
-	MOVHPD 0(R8)(SI*8), X0
-	MOVHPD 0(R9)(DI*8), X1
-	MOVLPD 0(R8)(AX*8), X0
-	MOVLPD 0(R9)(BX*8), X1
-	
-	MULPD X7, X0
-	ADDPD X0, X1
-	MOVHPD X1, 0(R9)(DI*8)
-	MOVLPD X1, 0(R9)(BX*8)
-
-	ADDQ R11, SI			// ix += incX
-	ADDQ R12, DI			// iy += incY
-	ADDQ R11, AX			// nextX += incX
-	ADDQ R12, BX			// nextY += incY
-
-	SUBQ $2, CX				// n -= 2
-	JGE U2					// if n >= 0 goto U2
-
-V2:
-	ADDQ $2, CX				// n += 2
-	JLE E2					// if n <= 0 goto E2
-	
-	// y[i] += alpha * x[i] for the last iteration if n is odd.
-	MOVSD 0(R8)(SI*8), X0
-	MOVSD 0(R9)(DI*8), X1
-	MULSD X7, X0
-	ADDSD X0, X1
-	MOVSD X1, 0(R9)(DI*8)
-
-E2:
-	RET
diff --git a/Godeps/_workspace/src/github.com/gonum/internal/asm/ddot.go b/Godeps/_workspace/src/github.com/gonum/internal/asm/ddot.go
deleted file mode 100644
index 7e69957..0000000
--- a/Godeps/_workspace/src/github.com/gonum/internal/asm/ddot.go
+++ /dev/null
@@ -1,23 +0,0 @@
-// Copyright ©2015 The gonum Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style
-// license that can be found in the LICENSE file.
-
-//+build !amd64 noasm
-
-package asm
-
-func DdotUnitary(x, y []float64) (sum float64) {
-	for i, v := range x {
-		sum += y[i] * v
-	}
-	return
-}
-
-func DdotInc(x, y []float64, n, incX, incY, ix, iy uintptr) (sum float64) {
-	for i := 0; i < int(n); i++ {
-		sum += y[iy] * x[ix]
-		ix += incX
-		iy += incY
-	}
-	return
-}
diff --git a/Godeps/_workspace/src/github.com/gonum/internal/asm/ddot_amd64.go b/Godeps/_workspace/src/github.com/gonum/internal/asm/ddot_amd64.go
deleted file mode 100644
index 7fa634a..0000000
--- a/Godeps/_workspace/src/github.com/gonum/internal/asm/ddot_amd64.go
+++ /dev/null
@@ -1,10 +0,0 @@
-// Copyright ©2015 The gonum Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style
-// license that can be found in the LICENSE file.
-
-//+build !noasm
-
-package asm
-
-func DdotUnitary(x, y []float64) (sum float64)
-func DdotInc(x, y []float64, n, incX, incY, ix, iy uintptr) (sum float64)
diff --git a/Godeps/_workspace/src/github.com/gonum/internal/asm/ddot_amd64.s b/Godeps/_workspace/src/github.com/gonum/internal/asm/ddot_amd64.s
deleted file mode 100644
index a898bbb..0000000
--- a/Godeps/_workspace/src/github.com/gonum/internal/asm/ddot_amd64.s
+++ /dev/null
@@ -1,140 +0,0 @@
-// Copyright ©2015 The gonum Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style
-// license that can be found in the LICENSE file.
-//
-// Some of the loop unrolling code is copied from:
-// http://golang.org/src/math/big/arith_amd64.s
-// which is distributed under these terms:
-//
-// Copyright (c) 2012 The Go Authors. All rights reserved.
-// 
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions are
-// met:
-// 
-//    * Redistributions of source code must retain the above copyright
-// notice, this list of conditions and the following disclaimer.
-//    * Redistributions in binary form must reproduce the above
-// copyright notice, this list of conditions and the following disclaimer
-// in the documentation and/or other materials provided with the
-// distribution.
-//    * Neither the name of Google Inc. nor the names of its
-// contributors may be used to endorse or promote products derived from
-// this software without specific prior written permission.
-// 
-// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
-// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
-// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
-// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
-// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
-// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
-// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
-// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
-// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-//+build !noasm
-
-// TODO(fhs): use textflag.h after we drop Go 1.3 support
-//#include "textflag.h"
-// Don't insert stack check preamble.
-#define NOSPLIT	4
-
-
-// func DdotUnitary(x, y []float64) (sum float64)
-// This function assumes len(y) >= len(x).
-TEXT ·DdotUnitary(SB),NOSPLIT,$0
-	MOVQ x_len+8(FP), DI	// n = len(x)
-	MOVQ x+0(FP), R8
-	MOVQ y+24(FP), R9
-	
-	MOVQ $0, SI				// i = 0
-	MOVSD $(0.0), X7		// sum = 0
-	
-	SUBQ $2, DI				// n -= 2
-	JL V1					// if n < 0 goto V1
-
-U1:	// n >= 0
-	// sum += x[i] * y[i] unrolled 2x.
-	MOVUPD 0(R8)(SI*8), X0
-	MOVUPD 0(R9)(SI*8), X1
-	MULPD X1, X0
-	ADDPD X0, X7
-	
-	ADDQ $2, SI				// i += 2
-	SUBQ $2, DI				// n -= 2
-	JGE U1					// if n >= 0 goto U1
-
-V1:	// n > 0
-	ADDQ $2, DI				// n += 2
-	JLE E1					// if n <= 0 goto E1
-	
-	// sum += x[i] * y[i] for last iteration if n is odd.
-	MOVSD 0(R8)(SI*8), X0
-	MOVSD 0(R9)(SI*8), X1
-	MULSD X1, X0
-	ADDSD X0, X7
-
-E1:
-	// Add the two sums together.
-	MOVSD X7, X0
-	UNPCKHPD X7, X7
-	ADDSD X0, X7
-	MOVSD X7, sum+48(FP)	// return final sum
-	RET
-
-
-// func DdotInc(x, y []float64, n, incX, incY, ix, iy uintptr) (sum float64)
-TEXT ·DdotInc(SB),NOSPLIT,$0
-	MOVQ x+0(FP), R8
-	MOVQ y+24(FP), R9
-	MOVQ n+48(FP), CX
-	MOVQ incX+56(FP), R11
-	MOVQ incY+64(FP), R12
-	MOVQ ix+72(FP), R13
-	MOVQ iy+80(FP), R14
-	
-	MOVSD $(0.0), X7		// sum = 0
-	LEAQ (R8)(R13*8), SI	// p = &x[ix]
-	LEAQ (R9)(R14*8), DI	// q = &y[ix]
-	SHLQ $3, R11			// incX *= sizeof(float64)
-	SHLQ $3, R12			// indY *= sizeof(float64)
-	
-	SUBQ $2, CX				// n -= 2
-	JL V2					// if n < 0 goto V2
-
-U2:	// n >= 0
-	// sum += *p * *q unrolled 2x.
-	MOVHPD (SI), X0
-	MOVHPD (DI), X1
-	ADDQ R11, SI			// p += incX
-	ADDQ R12, DI			// q += incY
-	MOVLPD (SI), X0
-	MOVLPD (DI), X1
-	ADDQ R11, SI			// p += incX
-	ADDQ R12, DI			// q += incY
-	
-	MULPD X1, X0
-	ADDPD X0, X7
-
-	SUBQ $2, CX				// n -= 2
-	JGE U2					// if n >= 0 goto U2
-
-V2:
-	ADDQ $2, CX				// n += 2
-	JLE E2					// if n <= 0 goto E2
-	
-	// sum += *p * *q for the last iteration if n is odd.
-	MOVSD (SI), X0
-	MULSD (DI), X0
-	ADDSD X0, X7
-
-E2:
-	// Add the two sums together.
-	MOVSD X7, X0
-	UNPCKHPD X7, X7
-	ADDSD X0, X7
-	MOVSD X7, sum+88(FP)	// return final sum
-	RET
-  
\ No newline at end of file
diff --git a/Godeps/_workspace/src/github.com/gonum/internal/asm/dsdot.go b/Godeps/_workspace/src/github.com/gonum/internal/asm/dsdot.go
deleted file mode 100644
index 8450689..0000000
--- a/Godeps/_workspace/src/github.com/gonum/internal/asm/dsdot.go
+++ /dev/null
@@ -1,23 +0,0 @@
-// Generated code do not edit. Run `go generate`.
-
-// Copyright ©2015 The gonum Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style
-// license that can be found in the LICENSE file.
-
-package asm
-
-func DsdotUnitary(x, y []float32) (sum float64) {
-	for i, v := range x {
-		sum += float64(y[i]) * float64(v)
-	}
-	return
-}
-
-func DsdotInc(x, y []float32, n, incX, incY, ix, iy uintptr) (sum float64) {
-	for i := 0; i < int(n); i++ {
-		sum += float64(y[iy]) * float64(x[ix])
-		ix += incX
-		iy += incY
-	}
-	return
-}
diff --git a/Godeps/_workspace/src/github.com/gonum/internal/asm/generate.go b/Godeps/_workspace/src/github.com/gonum/internal/asm/generate.go
deleted file mode 100644
index e252140..0000000
--- a/Godeps/_workspace/src/github.com/gonum/internal/asm/generate.go
+++ /dev/null
@@ -1,8 +0,0 @@
-// Copyright ©2015 The gonum Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style
-// license that can be found in the LICENSE file.
-
-//go:generate ./single_precision
-//go:generate ./complex
-
-package asm
diff --git a/Godeps/_workspace/src/github.com/gonum/internal/asm/saxpy.go b/Godeps/_workspace/src/github.com/gonum/internal/asm/saxpy.go
deleted file mode 100644
index 3ef767f..0000000
--- a/Godeps/_workspace/src/github.com/gonum/internal/asm/saxpy.go
+++ /dev/null
@@ -1,22 +0,0 @@
-// Generated code do not edit. Run `go generate`.
-
-// Copyright ©2015 The gonum Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style
-// license that can be found in the LICENSE file.
-
-package asm
-
-// The extra z parameter is needed because of floats.AddScaledTo
-func SaxpyUnitary(alpha float32, x, y, z []float32) {
-	for i, v := range x {
-		z[i] = alpha*v + y[i]
-	}
-}
-
-func SaxpyInc(alpha float32, x, y []float32, n, incX, incY, ix, iy uintptr) {
-	for i := 0; i < int(n); i++ {
-		y[iy] += alpha * x[ix]
-		ix += incX
-		iy += incY
-	}
-}
diff --git a/Godeps/_workspace/src/github.com/gonum/internal/asm/sdot.go b/Godeps/_workspace/src/github.com/gonum/internal/asm/sdot.go
deleted file mode 100644
index 0cef5de..0000000
--- a/Godeps/_workspace/src/github.com/gonum/internal/asm/sdot.go
+++ /dev/null
@@ -1,23 +0,0 @@
-// Generated code do not edit. Run `go generate`.
-
-// Copyright ©2015 The gonum Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style
-// license that can be found in the LICENSE file.
-
-package asm
-
-func SdotUnitary(x, y []float32) (sum float32) {
-	for i, v := range x {
-		sum += y[i] * v
-	}
-	return
-}
-
-func SdotInc(x, y []float32, n, incX, incY, ix, iy uintptr) (sum float32) {
-	for i := 0; i < int(n); i++ {
-		sum += y[iy] * x[ix]
-		ix += incX
-		iy += incY
-	}
-	return
-}
diff --git a/Godeps/_workspace/src/github.com/gonum/internal/asm/single_precision b/Godeps/_workspace/src/github.com/gonum/internal/asm/single_precision
deleted file mode 100644
index a937a97..0000000
--- a/Godeps/_workspace/src/github.com/gonum/internal/asm/single_precision
+++ /dev/null
@@ -1,30 +0,0 @@
-#!/usr/bin/env bash
-
-# Copyright ©2015 The gonum Authors. All rights reserved.
-# Use of this source code is governed by a BSD-style
-# license that can be found in the LICENSE file.
-
-echo Generating dsdot.go
-echo -e '// Generated code do not edit. Run `go generate`.\n' > dsdot.go
-cat ddot.go \
-| grep -v '//+build' \
-| gofmt -r '[]float64 -> []float32' \
-| gofmt -r 'a * b -> float64(a) * float64(b)' \
-| sed 's/Ddot/Dsdot/' \
->> dsdot.go
-
-echo Generating sdot.go
-echo -e '// Generated code do not edit. Run `go generate`.\n' > sdot.go
-cat ddot.go \
-| grep -v '//+build' \
-| gofmt -r 'float64 -> float32' \
-| sed 's/Ddot/Sdot/' \
->> sdot.go
-
-echo Generating saxpy.go
-echo -e '// Generated code do not edit. Run `go generate`.\n' > saxpy.go
-cat daxpy.go \
-| grep -v '//+build' \
-| gofmt -r 'float64 -> float32' \
-| sed 's/Daxpy/Saxpy/' \
->> saxpy.go
diff --git a/Godeps/_workspace/src/github.com/gonum/internal/asm/zaxpy.go b/Godeps/_workspace/src/github.com/gonum/internal/asm/zaxpy.go
deleted file mode 100644
index 9478f25..0000000
--- a/Godeps/_workspace/src/github.com/gonum/internal/asm/zaxpy.go
+++ /dev/null
@@ -1,22 +0,0 @@
-// Generated code do not edit. Run `go generate`.
-
-// Copyright ©2015 The gonum Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style
-// license that can be found in the LICENSE file.
-
-package asm
-
-// The extra z parameter is needed because of floats.AddScaledTo
-func ZaxpyUnitary(alpha complex128, x, y, z []complex128) {
-	for i, v := range x {
-		z[i] = alpha*v + y[i]
-	}
-}
-
-func ZaxpyInc(alpha complex128, x, y []complex128, n, incX, incY, ix, iy uintptr) {
-	for i := 0; i < int(n); i++ {
-		y[iy] += alpha * x[ix]
-		ix += incX
-		iy += incY
-	}
-}
diff --git a/Godeps/_workspace/src/github.com/gonum/internal/asm/zdotc.go b/Godeps/_workspace/src/github.com/gonum/internal/asm/zdotc.go
deleted file mode 100644
index 7b8febc..0000000
--- a/Godeps/_workspace/src/github.com/gonum/internal/asm/zdotc.go
+++ /dev/null
@@ -1,25 +0,0 @@
-// Generated code do not edit. Run `go generate`.
-
-// Copyright ©2015 The gonum Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style
-// license that can be found in the LICENSE file.
-
-package asm
-
-import "math/cmplx"
-
-func ZdotcUnitary(x, y []complex128) (sum complex128) {
-	for i, v := range x {
-		sum += y[i] * cmplx.Conj(v)
-	}
-	return
-}
-
-func ZdotcInc(x, y []complex128, n, incX, incY, ix, iy uintptr) (sum complex128) {
-	for i := 0; i < int(n); i++ {
-		sum += y[iy] * cmplx.Conj(x[ix])
-		ix += incX
-		iy += incY
-	}
-	return
-}
diff --git a/Godeps/_workspace/src/github.com/gonum/internal/asm/zdotu.go b/Godeps/_workspace/src/github.com/gonum/internal/asm/zdotu.go
deleted file mode 100644
index 82c1fe2..0000000
--- a/Godeps/_workspace/src/github.com/gonum/internal/asm/zdotu.go
+++ /dev/null
@@ -1,23 +0,0 @@
-// Generated code do not edit. Run `go generate`.
-
-// Copyright ©2015 The gonum Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style
-// license that can be found in the LICENSE file.
-
-package asm
-
-func ZdotuUnitary(x, y []complex128) (sum complex128) {
-	for i, v := range x {
-		sum += y[i] * v
-	}
-	return
-}
-
-func ZdotuInc(x, y []complex128, n, incX, incY, ix, iy uintptr) (sum complex128) {
-	for i := 0; i < int(n); i++ {
-		sum += y[iy] * x[ix]
-		ix += incX
-		iy += incY
-	}
-	return
-}
diff --git a/Godeps/_workspace/src/github.com/gonum/matrix/mat64/inner.go b/Godeps/_workspace/src/github.com/gonum/matrix/mat64/inner.go
index 77616ba..1610a83 100644
--- a/Godeps/_workspace/src/github.com/gonum/matrix/mat64/inner.go
+++ b/Godeps/_workspace/src/github.com/gonum/matrix/mat64/inner.go
@@ -6,7 +6,7 @@ package mat64
 
 import (
 	"github.com/gonum/blas"
-	"github.com/gonum/internal/asm"
+	"github.com/gonum/inteernal/asm"
 )
 
 // Inner computes the generalized inner product
-- 
1.9.3

